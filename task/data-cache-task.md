# 数据缓存优化任务计划

## 项目背景分析

### 当前问题
1. **性能问题**: 每次调用 `/investnote/ticker/hk/00001` 都会重新计算评分，消耗服务器资源
2. **数据结构问题**: `ticker_score.history` 字段存储的是分析数据（如 `raw_score`, `z_score`, `trend_strength` 等），而不是历史评分数据
3. **缓存缺失**: 缺乏基于时间戳的智能缓存机制
4. **市场时间判断**: 未充分利用市场开市时间进行优化判断

### 期望改进
1. **智能缓存**: 根据最新K线数据时间戳判断是否需要重新计算
2. **数据结构优化**: 分离分析数据和历史评分数据
3. **市场时间集成**: 利用 `Market` 模型的开市时间进行优化判断
4. **历史数据管理**: 实现滚动窗口机制，保持最近N天的历史评分

## 技术方案设计

### 1. 数据库层改造

#### 1.1 数据库表结构修改
```sql
-- 添加 analysis_data 字段存储分析数据
ALTER TABLE ticker_score ADD COLUMN analysis_data JSON;

-- 更新现有数据：将 history 字段内容迁移到 analysis_data
UPDATE ticker_score SET analysis_data = history WHERE history IS NOT NULL;

-- 清空 history 字段，准备用于存储历史评分数组
UPDATE ticker_score SET history = NULL;
```

#### 1.2 数据库索引优化
```sql
-- 添加复合索引提高查询性能
CREATE INDEX idx_ticker_score_ticker_time ON ticker_score(ticker_id, time_key);
CREATE INDEX idx_ticker_score_time_key ON ticker_score(time_key);
CREATE INDEX idx_ticker_score_analysis ON ticker_score(ticker_id, time_key, analysis_data);
```

### 2. 模型层改造

#### 2.1 TickerScore 模型更新
- **新增字段**: `analysis_data: Optional[dict]` - 存储分析数据
- **修改字段**: `history: Optional[list]` - 改为存储历史评分数组
- **更新序列化函数**: 支持新的字段结构
- **向后兼容**: 保持现有API接口不变

#### 2.2 数据迁移策略
- **分阶段迁移**: 先迁移少量数据验证，再全量迁移
- **数据验证**: 迁移前后进行数据完整性检查
- **回滚机制**: 提供一键回滚脚本，支持数据恢复
- **备份策略**: 迁移前自动备份数据库
- **监控机制**: 实时监控迁移进度和错误率

### 3. 业务逻辑层改造

#### 3.1 Score 计算逻辑优化
- **修改 Score 类**: 将分析数据存储到 `analysis_data` 字段
- **历史数据管理**: 实现滚动窗口，保持最近600天的历史评分（与数据获取默认天数一致）
- **数据压缩**: 对历史数据进行压缩存储

#### 3.2 缓存判断逻辑
```python
def _need_update_score(self, ticker: Ticker, latest_kline_time: str) -> bool:
    """
    判断是否需要更新评分
    
    判断条件：
    1. 最新评分时间 < 最新K线时间
    2. 当前是交易日且市场开市
    3. 距离上次更新超过一定时间间隔（默认30分钟）
    4. 数据源发生变化时需要重新计算
    """
    
def _get_market_trading_status(self, ticker: Ticker) -> dict:
    """
    获取市场交易状态
    
    Returns:
        {
            "is_trading_day": bool,
            "market_open": bool,
            "next_update_time": str,
            "timezone": str
        }
    """
```

#### 3.3 市场时间集成
- 利用 `Market.is_trading_day()` 判断是否为交易日
- 结合市场开市时间进行优化判断
- 支持不同市场的时区处理

### 4. 数据访问层优化

#### 4.1 TickerScoreRepository 增强
- **批量历史数据操作**: 支持批量获取和更新历史评分
- **时间范围查询**: 支持按时间范围查询历史数据
- **数据清理**: 实现过期数据清理机制

#### 4.2 数据获取策略
```python
def get_ticker_score_with_history(self, ticker_id: int, days: int = 600) -> dict:
    """
    获取股票评分及历史数据（默认600天，与数据获取保持一致）
    
    Returns:
        {
            "current_score": TickerScore,
            "history_scores": list[TickerScore],
            "analysis_data": dict
        }
    """
```

### 5. API层优化

#### 5.1 智能数据获取
- **缓存优先**: 优先返回缓存数据，避免重复计算
- **增量更新**: 只更新必要的数据部分
- **异步处理**: 支持异步数据更新

#### 5.2 响应格式优化
保持原有API响应格式不变，仅在响应中添加 `cache_info` 字段：

```json
{
    "ticker": {...},
    "kline_data": [...],
    "score_data": [...],  // 保持原有格式
    "cache_info": {
        "last_updated": "2024-01-01T10:00:00Z",
        "is_cached": true,
        "next_update": "2024-01-01T16:00:00Z"
    }
}
```

## 实施步骤

### Phase 1: 数据库和模型改造 (1-2天)

#### Step 1.1: 数据库表结构修改
- [ ] 执行数据库表结构修改SQL
- [ ] 创建数据迁移脚本
- [ ] 执行数据迁移，将现有history数据迁移到analysis_data
- [ ] 验证数据迁移结果

#### Step 1.2: 模型层更新
- [ ] 更新 `TickerScore` 模型，添加 `analysis_data` 字段
- [ ] 修改 `history` 字段用途，改为存储历史评分数组
- [ ] 更新序列化/反序列化函数
- [ ] 添加数据验证和转换逻辑

### Phase 2: 业务逻辑改造 (2-3天)

#### Step 2.1: Score 计算逻辑优化
- [ ] 修改 `Score` 类，将分析数据存储到 `analysis_data`
- [ ] 实现历史评分数据的数组存储逻辑
- [ ] 添加数据压缩和清理机制
- [ ] 保持向后兼容性

#### Step 2.2: 缓存判断逻辑实现
- [ ] 实现基于时间戳的缓存判断函数
- [ ] 集成市场开市时间判断逻辑
- [ ] 添加缓存失效策略
- [ ] 实现智能更新触发机制

#### Step 2.3: 数据访问层增强
- [ ] 增强 `TickerScoreRepository`，支持批量历史数据操作
- [ ] 实现时间范围查询功能
- [ ] 添加数据清理和压缩功能
- [ ] 优化数据库查询性能

### Phase 3: API层优化 (1-2天)

#### Step 3.1: 数据获取优化
- [ ] 修改 `DataSourceHelper` 的更新逻辑
- [ ] 实现智能数据获取策略
- [ ] 优化 API 响应格式
- [ ] 添加缓存信息返回

#### Step 3.2: 性能优化
- [ ] 实现异步数据更新机制
- [ ] 添加数据预加载功能
- [ ] 优化数据库连接池
- [ ] 实现请求合并和去重

### Phase 4: 测试和验证 (1-2天)

#### Step 4.1: 单元测试
- [ ] 为新功能编写单元测试
- [ ] 测试数据迁移脚本
- [ ] 测试缓存判断逻辑
- [ ] 测试历史数据管理
- [ ] 测试市场时间判断逻辑
- [ ] 测试数据压缩和清理机制
- [ ] 测试边界情况和异常处理

#### Step 4.2: 集成测试
- [ ] 测试端到端数据流程
- [ ] 验证API响应格式
- [ ] 测试性能优化效果
- [ ] 验证向后兼容性

#### Step 4.3: 性能测试
- [ ] 测试缓存命中率
- [ ] 验证数据库查询性能
- [ ] 测试并发访问性能
- [ ] 验证内存使用情况
- [ ] 测试数据迁移性能
- [ ] 验证缓存重建时间
- [ ] 测试不同数据量下的性能表现

## 风险评估和缓解措施

### 风险1: 数据迁移风险
- **风险**: 数据迁移过程中可能丢失数据
- **缓解**: 实施前备份数据库，提供回滚机制

### 风险2: 性能退化
- **风险**: 新逻辑可能影响现有性能
- **缓解**: 分阶段实施，持续监控性能指标

### 风险3: 向后兼容性问题
- **风险**: API变更可能影响现有客户端
- **缓解**: 保持API接口不变，内部实现优化

## 成功标准

### 性能指标
- [ ] 缓存命中率 > 80%
- [ ] API响应时间减少 > 50%
- [ ] 数据库查询次数减少 > 60%

### 功能指标
- [ ] 历史评分数据正确存储和获取
- [ ] 分析数据正确分离和存储
- [ ] 市场时间判断逻辑正确工作
- [ ] 缓存机制正常工作

### 质量指标
- [ ] 单元测试覆盖率 > 90%
- [ ] 集成测试通过率 100%
- [ ] 性能测试达标
- [ ] 向后兼容性验证通过

## 监控和维护

### 监控指标
- **缓存指标**: 缓存命中率、缓存重建时间、缓存大小
- **性能指标**: API响应时间、数据库查询性能、内存使用情况
- **业务指标**: 数据更新频率、错误率、数据一致性
- **系统指标**: CPU使用率、磁盘I/O、网络延迟

### 维护计划
- 定期清理过期数据
- 监控缓存效果
- 优化数据库索引
- 更新市场时间配置

## 时间计划

| 阶段 | 时间 | 负责人 | 交付物 |
|------|------|--------|--------|
| Phase 1 | 1-2天 | 开发团队 | 数据库改造完成，模型更新 |
| Phase 2 | 2-3天 | 开发团队 | 业务逻辑改造完成 |
| Phase 3 | 1-2天 | 开发团队 | API优化完成 |
| Phase 4 | 1-2天 | 测试团队 | 测试验证完成 |
| **总计** | **5-9天** | **团队协作** | **完整功能交付** |

## 技术债务清理

### 代码重构
- [ ] 清理重复代码
- [ ] 优化数据库查询
- [ ] 改进错误处理
- [ ] 增强日志记录

### 文档更新
- [ ] 更新API文档
- [ ] 更新数据库设计文档
- [ ] 更新部署文档
- [ ] 更新用户手册

---

**创建时间**: 2025-08-01T18:49:49+08:00  
**项目**: InvestNote-py  
**状态**: 待审核
