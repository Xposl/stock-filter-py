---
description: 
globs: 
alwaysApply: false
---
# InvestNote-py 通用AI代理架构设计规范

## 概述

本文档定义了InvestNote-py项目中通用AI代理系统的架构设计原则和开发规范，基于PocketFlow框架实现的多领域智能分析平台，支持新闻分析、股票分析、投资策略、市场监控、风险评估等全业务场景。

## 🏗️ 总体架构原则

### 1. 通用化设计原则

#### **领域无关性原则**
- AI代理框架不绑定特定业务领域
- 通过配置化和插件化支持任意业务场景
- 保持Agent、Node、Flow的通用性和可复用性

#### **多层次架构模式**
```
🌐 Agent Manager Layer (代理管理层)
    ├── Agent Registry (代理注册表)
    ├── Agent Factory (代理工厂)
    └── Agent Orchestrator (代理编排器)

🤖 Agent Layer (代理层)
    ├── News Analysis Agent (新闻分析代理)
    ├── Stock Analysis Agent (股票分析代理) 
    ├── Strategy Advisor Agent (策略顾问代理)
    ├── Risk Assessment Agent (风险评估代理)
    ├── Market Monitor Agent (市场监控代理)
    └── Portfolio Optimizer Agent (组合优化代理)

⚙️ Flow Layer (工作流层)
    ├── Multi-Step Analysis Flow (多步分析流)
    ├── Real-time Monitoring Flow (实时监控流)
    ├── Batch Processing Flow (批处理流)
    └── Interactive Advisory Flow (交互式咨询流)

🔧 Node Layer (节点层)
    ├── Data Ingestion Nodes (数据摄取节点)
    ├── Analysis Nodes (分析节点)
    ├── Decision Nodes (决策节点)
    └── Output Nodes (输出节点)

🛠️ Core Services Layer (核心服务层)
    ├── LLM Service (大语言模型服务)
    ├── Vector Database Service (向量数据库服务)
    ├── Cache Service (缓存服务)
    └── Monitoring Service (监控服务)
```

### 2. 目录结构规范

```
core/ai_agents/
├── __init__.py                          # 模块入口和全局配置
├── agent_manager/                       # 🆕 代理管理层
│   ├── __init__.py
│   ├── agent_registry.py               # 代理注册表 
│   ├── agent_factory.py                # 代理工厂
│   ├── agent_orchestrator.py           # 代理编排器
│   └── agent_config.py                 # 代理配置管理
├── agents/                              # 🆕 业务代理层
│   ├── __init__.py
│   ├── base_agent.py                   # 代理基类
│   ├── news_analysis_agent.py          # 新闻分析代理
│   ├── stock_analysis_agent.py         # 股票分析代理
│   ├── strategy_advisor_agent.py       # 策略顾问代理
│   ├── risk_assessment_agent.py        # 风险评估代理
│   ├── market_monitor_agent.py         # 市场监控代理
│   └── portfolio_optimizer_agent.py    # 组合优化代理
├── flows/                               # 🔄 重构：通用工作流层
│   ├── __init__.py
│   ├── base_flow.py                    # 工作流基类
│   ├── multi_step_analysis_flow.py     # 多步分析流
│   ├── real_time_monitor_flow.py       # 实时监控流
│   ├── batch_processing_flow.py        # 批处理流
│   └── interactive_advisory_flow.py    # 交互式咨询流
├── nodes/                               # 🔄 扩展：通用节点层
│   ├── __init__.py
│   ├── base_node.py                    # 节点基类
│   ├── data_ingestion/                 # 数据摄取节点
│   │   ├── news_ingestion_node.py      # 新闻数据摄取
│   │   ├── stock_data_ingestion_node.py # 股票数据摄取
│   │   ├── market_data_ingestion_node.py # 市场数据摄取
│   │   └── user_preference_node.py     # 用户偏好摄取
│   ├── analysis/                       # 分析节点
│   │   ├── sentiment_analysis_node.py  # 情感分析
│   │   ├── technical_analysis_node.py  # 技术分析
│   │   ├── fundamental_analysis_node.py # 基本面分析
│   │   ├── correlation_analysis_node.py # 相关性分析
│   │   └── trend_analysis_node.py      # 趋势分析
│   ├── decision/                       # 决策节点
│   │   ├── investment_decision_node.py # 投资决策
│   │   ├── risk_control_node.py        # 风险控制
│   │   ├── portfolio_balance_node.py   # 组合平衡
│   │   └── timing_decision_node.py     # 时机决策
│   └── output/                         # 输出节点
│       ├── report_generation_node.py   # 报告生成
│       ├── alert_notification_node.py  # 告警通知
│       ├── recommendation_node.py      # 推荐建议
│       └── visualization_node.py       # 可视化输出
├── core_services/                       # 🆕 核心服务层
│   ├── __init__.py
│   ├── llm_service/                    # LLM服务
│   │   ├── llm_client_factory.py       # LLM客户端工厂
│   │   ├── qwen_client.py              # 千问客户端
│   │   ├── prompt_manager.py           # 提示词管理
│   │   └── response_parser.py          # 响应解析器
│   ├── vector_service/                 # 向量数据库服务
│   │   ├── chroma_client.py            # ChromaDB客户端
│   │   ├── embedding_service.py        # 嵌入向量服务
│   │   └── similarity_search.py        # 相似性搜索
│   ├── cache_service/                  # 缓存服务
│   │   ├── redis_cache.py              # Redis缓存
│   │   ├── memory_cache.py             # 内存缓存
│   │   └── cache_strategy.py           # 缓存策略
│   └── monitoring_service/             # 监控服务
│       ├── metrics_collector.py        # 指标收集器
│       ├── performance_monitor.py      # 性能监控
│       └── alert_manager.py            # 告警管理
├── utils/                               # 🔄 扩展：通用工具层
│   ├── __init__.py
│   ├── data_validator.py               # 数据验证器
│   ├── result_formatter.py             # 结果格式化器
│   ├── configuration_loader.py         # 配置加载器
│   ├── security_utils.py               # 安全工具
│   └── async_utils.py                  # 异步工具
└── interfaces/                          # 🆕 接口定义层
    ├── __init__.py
    ├── agent_interface.py              # 代理接口
    ├── flow_interface.py               # 流程接口
    ├── node_interface.py               # 节点接口
    └── service_interface.py            # 服务接口
```

## 🤖 代理管理层 (Agent Manager Layer)

### 1. 代理注册表 (Agent Registry)

[core/ai_agents/agent_manager/agent_registry.py](mdc:core/ai_agents/agent_manager/agent_registry.py)
```python
from typing import Dict, Type, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
from ..interfaces.agent_interface import BaseAgent

class AgentCategory(Enum):
    """代理分类"""
    ANALYSIS = "analysis"          # 分析类代理
    ADVISORY = "advisory"          # 咨询类代理  
    MONITORING = "monitoring"      # 监控类代理
    OPTIMIZATION = "optimization"  # 优化类代理
    REPORTING = "reporting"        # 报告类代理

@dataclass
class AgentMetadata:
    """代理元数据"""
    name: str
    description: str
    category: AgentCategory
    version: str
    capabilities: List[str]
    dependencies: List[str]
    input_schemas: Dict[str, Any]
    output_schemas: Dict[str, Any]
    performance_requirements: Dict[str, Any]

class AgentRegistry:
    """代理注册表 - 管理所有可用的AI代理"""
    
    def __init__(self):
        self._agents: Dict[str, Type[BaseAgent]] = {}
        self._metadata: Dict[str, AgentMetadata] = {}
        self._categories: Dict[AgentCategory, List[str]] = {
            category: [] for category in AgentCategory
        }
    
    def register_agent(self, agent_name: str, agent_class: Type[BaseAgent], 
                      metadata: AgentMetadata) -> None:
        """注册新代理"""
        self._agents[agent_name] = agent_class
        self._metadata[agent_name] = metadata
        self._categories[metadata.category].append(agent_name)
    
    def get_agent_class(self, agent_name: str) -> Optional[Type[BaseAgent]]:
        """获取代理类"""
        return self._agents.get(agent_name)
    
    def get_agents_by_category(self, category: AgentCategory) -> List[str]:
        """按分类获取代理列表"""
        return self._categories.get(category, [])
    
    def get_agent_capabilities(self, agent_name: str) -> List[str]:
        """获取代理能力列表"""
        metadata = self._metadata.get(agent_name)
        return metadata.capabilities if metadata else []
    
    def find_agents_by_capability(self, capability: str) -> List[str]:
        """根据能力查找代理"""
        matching_agents = []
        for agent_name, metadata in self._metadata.items():
            if capability in metadata.capabilities:
                matching_agents.append(agent_name)
        return matching_agents

# 全局代理注册表实例
agent_registry = AgentRegistry()
```

### 2. 代理工厂 (Agent Factory)

[core/ai_agents/agent_manager/agent_factory.py](mdc:core/ai_agents/agent_manager/agent_factory.py)
```python
from typing import Dict, Any, Optional
from .agent_registry import agent_registry, AgentCategory
from .agent_config import AgentConfigManager
from ..interfaces.agent_interface import BaseAgent
from ..core_services.llm_service.llm_client_factory import LLMClientFactory
from ..core_services.vector_service.chroma_client import ChromaClient

class AgentFactory:
    """代理工厂 - 负责创建和配置AI代理实例"""
    
    def __init__(self):
        self.config_manager = AgentConfigManager()
        self.llm_factory = LLMClientFactory()
        self.vector_client = ChromaClient()
    
    def create_agent(self, agent_name: str, 
                    config_override: Optional[Dict[str, Any]] = None) -> BaseAgent:
        """创建代理实例"""
        
        # 获取代理类
        agent_class = agent_registry.get_agent_class(agent_name)
        if not agent_class:
            raise ValueError(f"未知的代理类型: {agent_name}")
        
        # 加载配置
        agent_config = self.config_manager.get_agent_config(agent_name)
        if config_override:
            agent_config.update(config_override)
        
        # 创建依赖服务
        llm_client = self.llm_factory.create_client(
            agent_config.get("llm_provider", "qwen")
        )
        
        # 实例化代理
        agent_instance = agent_class(
            config=agent_config,
            llm_client=llm_client,
            vector_client=self.vector_client
        )
        
        return agent_instance
    
    def create_agent_pipeline(self, agent_names: List[str], 
                            pipeline_config: Dict[str, Any]) -> 'AgentPipeline':
        """创建代理管道"""
        agents = []
        for agent_name in agent_names:
            agent = self.create_agent(agent_name)
            agents.append(agent)
        
        return AgentPipeline(agents, pipeline_config)
    
    def get_recommended_agents(self, task_description: str, 
                             requirements: Dict[str, Any]) -> List[str]:
        """根据任务描述推荐合适的代理"""
        # 基于任务描述和需求，使用LLM推荐合适的代理组合
        recommended_agents = self._llm_recommend_agents(
            task_description, requirements
        )
        return recommended_agents

# 全局代理工厂实例
agent_factory = AgentFactory()
```

### 3. 代理编排器 (Agent Orchestrator)

[core/ai_agents/agent_manager/agent_orchestrator.py](mdc:core/ai_agents/agent_manager/agent_orchestrator.py)
```python
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum
import asyncio
from datetime import datetime

class OrchestrationMode(Enum):
    """编排模式"""
    SEQUENTIAL = "sequential"      # 顺序执行
    PARALLEL = "parallel"          # 并行执行
    CONDITIONAL = "conditional"    # 条件执行
    ITERATIVE = "iterative"        # 迭代执行

@dataclass
class TaskContext:
    """任务上下文"""
    task_id: str
    user_id: str
    task_type: str
    input_data: Dict[str, Any]
    requirements: Dict[str, Any]
    context_data: Dict[str, Any]
    created_at: datetime

class AgentOrchestrator:
    """代理编排器 - 协调多个AI代理协作完成复杂任务"""
    
    def __init__(self):
        self.agent_factory = agent_factory
        self.active_tasks: Dict[str, TaskContext] = {}
        self.task_results: Dict[str, Dict[str, Any]] = {}
    
    async def execute_task(self, task_context: TaskContext, 
                          orchestration_plan: Dict[str, Any]) -> Dict[str, Any]:
        """执行复杂任务"""
        task_id = task_context.task_id
        self.active_tasks[task_id] = task_context
        
        try:
            mode = OrchestrationMode(orchestration_plan.get("mode", "sequential"))
            
            if mode == OrchestrationMode.SEQUENTIAL:
                result = await self._execute_sequential(task_context, orchestration_plan)
            elif mode == OrchestrationMode.PARALLEL:
                result = await self._execute_parallel(task_context, orchestration_plan)
            elif mode == OrchestrationMode.CONDITIONAL:
                result = await self._execute_conditional(task_context, orchestration_plan)
            elif mode == OrchestrationMode.ITERATIVE:
                result = await self._execute_iterative(task_context, orchestration_plan)
            else:
                raise ValueError(f"不支持的编排模式: {mode}")
            
            self.task_results[task_id] = result
            return result
            
        finally:
            # 清理任务上下文
            if task_id in self.active_tasks:
                del self.active_tasks[task_id]
    
    async def _execute_sequential(self, task_context: TaskContext, 
                                plan: Dict[str, Any]) -> Dict[str, Any]:
        """顺序执行多个代理"""
        agents = plan["agents"]
        context_data = task_context.context_data.copy()
        results = {}
        
        for step_config in agents:
            agent_name = step_config["agent"]
            agent_config = step_config.get("config", {})
            
            # 创建代理实例
            agent = self.agent_factory.create_agent(agent_name, agent_config)
            
            # 执行代理任务
            step_result = await agent.execute_async(
                input_data=context_data,
                task_context=task_context
            )
            
            # 更新上下文数据
            context_data.update(step_result.get("context_updates", {}))
            results[agent_name] = step_result
        
        return {
            "mode": "sequential",
            "agent_results": results,
            "final_context": context_data,
            "task_id": task_context.task_id
        }
    
    async def _execute_parallel(self, task_context: TaskContext, 
                              plan: Dict[str, Any]) -> Dict[str, Any]:
        """并行执行多个代理"""
        agents = plan["agents"]
        tasks = []
        
        for step_config in agents:
            agent_name = step_config["agent"]
            agent_config = step_config.get("config", {})
            
            # 创建代理实例
            agent = self.agent_factory.create_agent(agent_name, agent_config)
            
            # 创建异步任务
            task = asyncio.create_task(
                agent.execute_async(
                    input_data=task_context.context_data,
                    task_context=task_context
                )
            )
            tasks.append((agent_name, task))
        
        # 等待所有任务完成
        results = {}
        for agent_name, task in tasks:
            try:
                result = await task
                results[agent_name] = result
            except Exception as e:
                results[agent_name] = {"error": str(e), "success": False}
        
        return {
            "mode": "parallel",
            "agent_results": results,
            "task_id": task_context.task_id
        }

# 全局代理编排器实例
agent_orchestrator = AgentOrchestrator()
```

## 🎯 通用代理基类 (Base Agent)

### 代理接口定义

[core/ai_agents/interfaces/agent_interface.py](mdc:core/ai_agents/interfaces/agent_interface.py)
```python
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from datetime import datetime

@dataclass
class AgentExecutionResult:
    """代理执行结果"""
    success: bool
    result_data: Dict[str, Any]
    context_updates: Dict[str, Any]
    execution_time: float
    error_message: Optional[str] = None
    confidence_score: Optional[float] = None
    recommendations: List[str] = None

class BaseAgent(ABC):
    """AI代理基类接口"""
    
    def __init__(self, config: Dict[str, Any], llm_client: Any, 
                 vector_client: Any):
        self.config = config
        self.llm_client = llm_client
        self.vector_client = vector_client
        self.execution_metrics = {
            "total_executions": 0,
            "successful_executions": 0,
            "average_execution_time": 0.0,
            "last_execution": None
        }
    
    @abstractmethod
    async def execute_async(self, input_data: Dict[str, Any], 
                           task_context: Optional[Any] = None) -> AgentExecutionResult:
        """异步执行代理任务"""
        pass
    
    @abstractmethod
    def get_capabilities(self) -> List[str]:
        """获取代理能力列表"""
        pass
    
    @abstractmethod
    def validate_input(self, input_data: Dict[str, Any]) -> bool:
        """验证输入数据"""
        pass
    
    def get_execution_metrics(self) -> Dict[str, Any]:
        """获取执行指标"""
        return self.execution_metrics.copy()
```

### 通用代理实现基类

[core/ai_agents/agents/base_agent.py](mdc:core/ai_agents/agents/base_agent.py)
```python
from typing import Dict, Any, List, Optional
from datetime import datetime
import logging
from ..interfaces.agent_interface import BaseAgent, AgentExecutionResult

logger = logging.getLogger(__name__)

class UniversalAgent(BaseAgent):
    """通用AI代理基类实现"""
    
    def __init__(self, config: Dict[str, Any], llm_client: Any, 
                 vector_client: Any):
        super().__init__(config, llm_client, vector_client)
        self.agent_name = config.get("agent_name", self.__class__.__name__)
        self.capabilities = config.get("capabilities", [])
        self.max_retries = config.get("max_retries", 3)
        self.timeout = config.get("timeout", 300)
    
    async def execute_async(self, input_data: Dict[str, Any], 
                           task_context: Optional[Any] = None) -> AgentExecutionResult:
        """通用异步执行框架"""
        start_time = datetime.now()
        
        try:
            # 1. 输入验证
            if not self.validate_input(input_data):
                raise ValueError("输入数据验证失败")
            
            # 2. 预处理
            processed_data = await self.preprocess_data(input_data, task_context)
            
            # 3. 核心执行
            result_data = await self.execute_core_logic(processed_data, task_context)
            
            # 4. 后处理
            final_result = await self.postprocess_result(result_data, task_context)
            
            # 5. 更新指标
            execution_time = (datetime.now() - start_time).total_seconds()
            self._update_metrics(True, execution_time)
            
            return AgentExecutionResult(
                success=True,
                result_data=final_result,
                context_updates=self.get_context_updates(final_result),
                execution_time=execution_time,
                confidence_score=self.calculate_confidence(final_result),
                recommendations=self.generate_recommendations(final_result)
            )
            
        except Exception as e:
            execution_time = (datetime.now() - start_time).total_seconds()
            self._update_metrics(False, execution_time)
            
            logger.error(f"{self.agent_name} 执行失败: {e}")
            
            return AgentExecutionResult(
                success=False,
                result_data={},
                context_updates={},
                execution_time=execution_time,
                error_message=str(e)
            )
    
    @abstractmethod
    async def execute_core_logic(self, processed_data: Dict[str, Any], 
                               task_context: Optional[Any]) -> Dict[str, Any]:
        """核心业务逻辑 - 子类必须实现"""
        pass
    
    async def preprocess_data(self, input_data: Dict[str, Any], 
                            task_context: Optional[Any]) -> Dict[str, Any]:
        """数据预处理 - 子类可选重写"""
        return input_data
    
    async def postprocess_result(self, result_data: Dict[str, Any], 
                               task_context: Optional[Any]) -> Dict[str, Any]:
        """结果后处理 - 子类可选重写"""
        return result_data
    
    def get_context_updates(self, result_data: Dict[str, Any]) -> Dict[str, Any]:
        """获取上下文更新 - 子类可选重写"""
        return {}
    
    def calculate_confidence(self, result_data: Dict[str, Any]) -> float:
        """计算置信度 - 子类可选重写"""
        return 0.8
    
    def generate_recommendations(self, result_data: Dict[str, Any]) -> List[str]:
        """生成推荐建议 - 子类可选重写"""
        return []
    
    def get_capabilities(self) -> List[str]:
        """获取代理能力"""
        return self.capabilities
    
    def validate_input(self, input_data: Dict[str, Any]) -> bool:
        """基础输入验证"""
        return isinstance(input_data, dict)
    
    def _update_metrics(self, success: bool, execution_time: float):
        """更新执行指标"""
        self.execution_metrics["total_executions"] += 1
        if success:
            self.execution_metrics["successful_executions"] += 1
        
        # 更新平均执行时间
        total = self.execution_metrics["total_executions"]
        current_avg = self.execution_metrics["average_execution_time"]
        self.execution_metrics["average_execution_time"] = (
            (current_avg * (total - 1) + execution_time) / total
        )
        
        self.execution_metrics["last_execution"] = datetime.now()
```

## 🔄 业务代理示例

### 股票分析代理

[core/ai_agents/agents/stock_analysis_agent.py](mdc:core/ai_agents/agents/stock_analysis_agent.py)
```python
from typing import Dict, Any, List, Optional
from .base_agent import UniversalAgent
from core.data_providers.stock_data_factory import get_stock_quote, get_stock_info
from core.handler.ticker_score_handler import TickerScoreHandler

class StockAnalysisAgent(UniversalAgent):
    """股票分析代理 - 专门处理股票相关的智能分析"""
    
    def __init__(self, config: Dict[str, Any], llm_client: Any, vector_client: Any):
        super().__init__(config, llm_client, vector_client)
        self.score_handler = TickerScoreHandler()
        self.analysis_types = config.get("analysis_types", ["technical", "fundamental"])
    
    async def execute_core_logic(self, processed_data: Dict[str, Any], 
                               task_context: Optional[Any]) -> Dict[str, Any]:
        """执行股票分析核心逻辑"""
        stock_codes = processed_data.get("stock_codes", [])
        analysis_type = processed_data.get("analysis_type", "comprehensive")
        
        analysis_results = []
        
        for stock_code in stock_codes:
            # 获取股票基础信息
            stock_info = get_stock_info(stock_code)
            if not stock_info:
                continue
            
            # 获取实时行情
            stock_quote = get_stock_quote(stock_code)
            
            # 执行不同类型的分析
            stock_analysis = {
                "stock_code": stock_code,
                "stock_info": stock_info,
                "current_quote": stock_quote
            }
            
            if "technical" in self.analysis_types:
                stock_analysis["technical_analysis"] = await self._technical_analysis(
                    stock_code, stock_quote
                )
            
            if "fundamental" in self.analysis_types:
                stock_analysis["fundamental_analysis"] = await self._fundamental_analysis(
                    stock_code, stock_info
                )
            
            if "sentiment" in self.analysis_types:
                stock_analysis["sentiment_analysis"] = await self._sentiment_analysis(
                    stock_code
                )
            
            # 综合评分
            stock_analysis["overall_score"] = await self._calculate_overall_score(
                stock_analysis
            )
            
            analysis_results.append(stock_analysis)
        
        return {
            "analysis_type": analysis_type,
            "analyzed_stocks": analysis_results,
            "summary": self._generate_summary(analysis_results)
        }
    
    async def _technical_analysis(self, stock_code: str, 
                                stock_quote: Dict[str, Any]) -> Dict[str, Any]:
        """技术分析"""
        # 使用LLM进行技术指标分析
        prompt = f"""
        分析股票 {stock_code} 的技术指标：
        当前价格: {stock_quote.get('current_price')}
        涨跌幅: {stock_quote.get('change_percent')}
        
        请分析技术趋势并给出评分。
        """
        
        response = await self.llm_client.chat_completion_async([
            {"role": "user", "content": prompt}
        ])
        
        return {
            "trend_direction": "上涨/下跌/横盘",
            "support_level": 0.0,
            "resistance_level": 0.0,
            "technical_score": 0.8,
            "analysis_detail": response.get("content", "")
        }
    
    def get_capabilities(self) -> List[str]:
        """股票分析代理的能力"""
        return [
            "technical_analysis",       # 技术分析
            "fundamental_analysis",     # 基本面分析  
            "sentiment_analysis",       # 情感分析
            "stock_scoring",           # 股票评分
            "trend_prediction",        # 趋势预测
            "risk_assessment",         # 风险评估
            "portfolio_analysis"       # 组合分析
        ]
    
    def validate_input(self, input_data: Dict[str, Any]) -> bool:
        """验证股票分析输入"""
        if not super().validate_input(input_data):
            return False
        
        # 必须包含股票代码
        stock_codes = input_data.get("stock_codes")
        if not stock_codes or not isinstance(stock_codes, list):
            return False
        
        return True
```

### 新闻分析代理

[core/ai_agents/agents/news_analysis_agent.py](mdc:core/ai_agents/agents/news_analysis_agent.py)  
```python
from typing import Dict, Any, List, Optional
from .base_agent import UniversalAgent
from core.models.news_article import NewsArticle

class NewsAnalysisAgent(UniversalAgent):
    """新闻分析代理 - 专门处理新闻相关的智能分析"""
    
    def __init__(self, config: Dict[str, Any], llm_client: Any, vector_client: Any):
        super().__init__(config, llm_client, vector_client)
        self.analysis_depth = config.get("analysis_depth", "standard")
        self.extract_stocks = config.get("extract_stocks", True)
    
    async def execute_core_logic(self, processed_data: Dict[str, Any], 
                               task_context: Optional[Any]) -> Dict[str, Any]:
        """执行新闻分析核心逻辑"""
        articles = processed_data.get("articles", [])
        analysis_focus = processed_data.get("analysis_focus", "general")
        
        analysis_results = []
        
        for article in articles:
            article_analysis = await self._analyze_single_article(
                article, analysis_focus
            )
            analysis_results.append(article_analysis)
        
        # 综合分析
        comprehensive_analysis = await self._comprehensive_analysis(
            analysis_results
        )
        
        return {
            "individual_analyses": analysis_results,
            "comprehensive_analysis": comprehensive_analysis,
            "market_sentiment": self._extract_market_sentiment(analysis_results),
            "investment_implications": self._extract_investment_implications(analysis_results)
        }
    
    async def _analyze_single_article(self, article: NewsArticle, 
                                    focus: str) -> Dict[str, Any]:
        """分析单篇文章"""
        
        # 构建分析提示词
        prompt = f"""
        分析以下新闻文章，重点关注 {focus}：
        
        标题: {article.title}
        内容: {article.content[:2000]}...
        
        请分析：
        1. 文章主要主题和关键信息
        2. 涉及的股票或行业
        3. 市场情感倾向
        4. 投资相关性
        5. 重要性评分 (1-10)
        """
        
        response = await self.llm_client.chat_completion_async([
            {"role": "user", "content": prompt}
        ])
        
        # 使用向量数据库查找相似文章
        similar_articles = await self._find_similar_articles(article)
        
        return {
            "article_id": article.id,
            "main_theme": "主题提取",
            "mentioned_stocks": await self._extract_stocks(article) if self.extract_stocks else [],
            "sentiment_score": 0.6,  # -1 到 1
            "importance_score": 7,   # 1 到 10
            "investment_relevance": "高/中/低",
            "similar_articles": similar_articles,
            "detailed_analysis": response.get("content", "")
        }
    
    def get_capabilities(self) -> List[str]:
        """新闻分析代理的能力"""
        return [
            "sentiment_analysis",      # 情感分析
            "topic_extraction",        # 主题提取
            "stock_mention_detection", # 股票提及检测
            "importance_scoring",      # 重要性评分
            "trend_identification",    # 趋势识别
            "market_impact_analysis",  # 市场影响分析
            "content_summarization"    # 内容摘要
        ]
```

## 📊 监控和性能规范

### 代理性能监控

```python
class AgentPerformanceMonitor:
    """代理性能监控器"""
    
    def __init__(self):
        self.metrics = {}
        self.alert_thresholds = {
            "max_execution_time": 300,  # 最大执行时间（秒）
            "min_success_rate": 0.95,   # 最小成功率
            "max_error_rate": 0.05      # 最大错误率
        }
    
    def record_execution(self, agent_name: str, result: AgentExecutionResult):
        """记录代理执行结果"""
        if agent_name not in self.metrics:
            self.metrics[agent_name] = {
                "total_executions": 0,
                "successful_executions": 0,
                "total_execution_time": 0.0,
                "errors": []
            }
        
        metrics = self.metrics[agent_name]
        metrics["total_executions"] += 1
        
        if result.success:
            metrics["successful_executions"] += 1
        else:
            metrics["errors"].append({
                "timestamp": datetime.now(),
                "error": result.error_message
            })
        
        metrics["total_execution_time"] += result.execution_time
        
        # 检查告警条件
        self._check_alerts(agent_name, metrics)
```

## 🚀 最佳实践

### 1. 代理设计原则
- **单一职责**: 每个代理专注于特定的业务领域
- **可组合性**: 代理之间可以灵活组合协作
- **可配置性**: 通过配置文件调整代理行为
- **可监控性**: 内置完整的性能和错误监控

### 2. 多代理协作模式
- **管道模式**: 代理按顺序处理数据
- **并行模式**: 多个代理同时处理不同方面
- **分层模式**: 不同层次的代理处理不同抽象级别
- **反馈模式**: 代理之间相互提供反馈和调整

### 3. 性能优化策略
- **缓存机制**: 缓存重复的LLM调用结果
- **批处理**: 批量处理相似的任务
- **异步执行**: 使用异步编程提高并发性能
- **资源池化**: 复用LLM客户端和数据库连接

这个重新设计的通用AI代理架构不再局限于新闻分析，而是提供了一个完整的、可扩展的AI代理框架，能够支持投资分析的所有业务场景。
