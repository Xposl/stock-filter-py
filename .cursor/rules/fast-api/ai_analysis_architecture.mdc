---
description: 
globs: 
alwaysApply: false
---
# InvestNote-py é€šç”¨AIä»£ç†æ¶æ„è®¾è®¡è§„èŒƒ

## æ¦‚è¿°

æœ¬æ–‡æ¡£å®šä¹‰äº†InvestNote-pyé¡¹ç›®ä¸­é€šç”¨AIä»£ç†ç³»ç»Ÿçš„æ¶æ„è®¾è®¡åŸåˆ™å’Œå¼€å‘è§„èŒƒï¼ŒåŸºäºPocketFlowæ¡†æ¶å®ç°çš„å¤šé¢†åŸŸæ™ºèƒ½åˆ†æå¹³å°ï¼Œæ”¯æŒæ–°é—»åˆ†æã€è‚¡ç¥¨åˆ†æã€æŠ•èµ„ç­–ç•¥ã€å¸‚åœºç›‘æ§ã€é£é™©è¯„ä¼°ç­‰å…¨ä¸šåŠ¡åœºæ™¯ã€‚

## ğŸ—ï¸ æ€»ä½“æ¶æ„åŸåˆ™

### 1. é€šç”¨åŒ–è®¾è®¡åŸåˆ™

#### **é¢†åŸŸæ— å…³æ€§åŸåˆ™**
- AIä»£ç†æ¡†æ¶ä¸ç»‘å®šç‰¹å®šä¸šåŠ¡é¢†åŸŸ
- é€šè¿‡é…ç½®åŒ–å’Œæ’ä»¶åŒ–æ”¯æŒä»»æ„ä¸šåŠ¡åœºæ™¯
- ä¿æŒAgentã€Nodeã€Flowçš„é€šç”¨æ€§å’Œå¯å¤ç”¨æ€§

#### **å¤šå±‚æ¬¡æ¶æ„æ¨¡å¼**
```
ğŸŒ Agent Manager Layer (ä»£ç†ç®¡ç†å±‚)
    â”œâ”€â”€ Agent Registry (ä»£ç†æ³¨å†Œè¡¨)
    â”œâ”€â”€ Agent Factory (ä»£ç†å·¥å‚)
    â””â”€â”€ Agent Orchestrator (ä»£ç†ç¼–æ’å™¨)

ğŸ¤– Agent Layer (ä»£ç†å±‚)
    â”œâ”€â”€ News Analysis Agent (æ–°é—»åˆ†æä»£ç†)
    â”œâ”€â”€ Stock Analysis Agent (è‚¡ç¥¨åˆ†æä»£ç†) 
    â”œâ”€â”€ Strategy Advisor Agent (ç­–ç•¥é¡¾é—®ä»£ç†)
    â”œâ”€â”€ Risk Assessment Agent (é£é™©è¯„ä¼°ä»£ç†)
    â”œâ”€â”€ Market Monitor Agent (å¸‚åœºç›‘æ§ä»£ç†)
    â””â”€â”€ Portfolio Optimizer Agent (ç»„åˆä¼˜åŒ–ä»£ç†)

âš™ï¸ Flow Layer (å·¥ä½œæµå±‚)
    â”œâ”€â”€ Multi-Step Analysis Flow (å¤šæ­¥åˆ†ææµ)
    â”œâ”€â”€ Real-time Monitoring Flow (å®æ—¶ç›‘æ§æµ)
    â”œâ”€â”€ Batch Processing Flow (æ‰¹å¤„ç†æµ)
    â””â”€â”€ Interactive Advisory Flow (äº¤äº’å¼å’¨è¯¢æµ)

ğŸ”§ Node Layer (èŠ‚ç‚¹å±‚)
    â”œâ”€â”€ Data Ingestion Nodes (æ•°æ®æ‘„å–èŠ‚ç‚¹)
    â”œâ”€â”€ Analysis Nodes (åˆ†æèŠ‚ç‚¹)
    â”œâ”€â”€ Decision Nodes (å†³ç­–èŠ‚ç‚¹)
    â””â”€â”€ Output Nodes (è¾“å‡ºèŠ‚ç‚¹)

ğŸ› ï¸ Core Services Layer (æ ¸å¿ƒæœåŠ¡å±‚)
    â”œâ”€â”€ LLM Service (å¤§è¯­è¨€æ¨¡å‹æœåŠ¡)
    â”œâ”€â”€ Vector Database Service (å‘é‡æ•°æ®åº“æœåŠ¡)
    â”œâ”€â”€ Cache Service (ç¼“å­˜æœåŠ¡)
    â””â”€â”€ Monitoring Service (ç›‘æ§æœåŠ¡)
```

### 2. ç›®å½•ç»“æ„è§„èŒƒ

```
core/ai_agents/
â”œâ”€â”€ __init__.py                          # æ¨¡å—å…¥å£å’Œå…¨å±€é…ç½®
â”œâ”€â”€ agent_manager/                       # ğŸ†• ä»£ç†ç®¡ç†å±‚
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ agent_registry.py               # ä»£ç†æ³¨å†Œè¡¨ 
â”‚   â”œâ”€â”€ agent_factory.py                # ä»£ç†å·¥å‚
â”‚   â”œâ”€â”€ agent_orchestrator.py           # ä»£ç†ç¼–æ’å™¨
â”‚   â””â”€â”€ agent_config.py                 # ä»£ç†é…ç½®ç®¡ç†
â”œâ”€â”€ agents/                              # ğŸ†• ä¸šåŠ¡ä»£ç†å±‚
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base_agent.py                   # ä»£ç†åŸºç±»
â”‚   â”œâ”€â”€ news_analysis_agent.py          # æ–°é—»åˆ†æä»£ç†
â”‚   â”œâ”€â”€ stock_analysis_agent.py         # è‚¡ç¥¨åˆ†æä»£ç†
â”‚   â”œâ”€â”€ strategy_advisor_agent.py       # ç­–ç•¥é¡¾é—®ä»£ç†
â”‚   â”œâ”€â”€ risk_assessment_agent.py        # é£é™©è¯„ä¼°ä»£ç†
â”‚   â”œâ”€â”€ market_monitor_agent.py         # å¸‚åœºç›‘æ§ä»£ç†
â”‚   â””â”€â”€ portfolio_optimizer_agent.py    # ç»„åˆä¼˜åŒ–ä»£ç†
â”œâ”€â”€ flows/                               # ğŸ”„ é‡æ„ï¼šé€šç”¨å·¥ä½œæµå±‚
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base_flow.py                    # å·¥ä½œæµåŸºç±»
â”‚   â”œâ”€â”€ multi_step_analysis_flow.py     # å¤šæ­¥åˆ†ææµ
â”‚   â”œâ”€â”€ real_time_monitor_flow.py       # å®æ—¶ç›‘æ§æµ
â”‚   â”œâ”€â”€ batch_processing_flow.py        # æ‰¹å¤„ç†æµ
â”‚   â””â”€â”€ interactive_advisory_flow.py    # äº¤äº’å¼å’¨è¯¢æµ
â”œâ”€â”€ nodes/                               # ğŸ”„ æ‰©å±•ï¼šé€šç”¨èŠ‚ç‚¹å±‚
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base_node.py                    # èŠ‚ç‚¹åŸºç±»
â”‚   â”œâ”€â”€ data_ingestion/                 # æ•°æ®æ‘„å–èŠ‚ç‚¹
â”‚   â”‚   â”œâ”€â”€ news_ingestion_node.py      # æ–°é—»æ•°æ®æ‘„å–
â”‚   â”‚   â”œâ”€â”€ stock_data_ingestion_node.py # è‚¡ç¥¨æ•°æ®æ‘„å–
â”‚   â”‚   â”œâ”€â”€ market_data_ingestion_node.py # å¸‚åœºæ•°æ®æ‘„å–
â”‚   â”‚   â””â”€â”€ user_preference_node.py     # ç”¨æˆ·åå¥½æ‘„å–
â”‚   â”œâ”€â”€ analysis/                       # åˆ†æèŠ‚ç‚¹
â”‚   â”‚   â”œâ”€â”€ sentiment_analysis_node.py  # æƒ…æ„Ÿåˆ†æ
â”‚   â”‚   â”œâ”€â”€ technical_analysis_node.py  # æŠ€æœ¯åˆ†æ
â”‚   â”‚   â”œâ”€â”€ fundamental_analysis_node.py # åŸºæœ¬é¢åˆ†æ
â”‚   â”‚   â”œâ”€â”€ correlation_analysis_node.py # ç›¸å…³æ€§åˆ†æ
â”‚   â”‚   â””â”€â”€ trend_analysis_node.py      # è¶‹åŠ¿åˆ†æ
â”‚   â”œâ”€â”€ decision/                       # å†³ç­–èŠ‚ç‚¹
â”‚   â”‚   â”œâ”€â”€ investment_decision_node.py # æŠ•èµ„å†³ç­–
â”‚   â”‚   â”œâ”€â”€ risk_control_node.py        # é£é™©æ§åˆ¶
â”‚   â”‚   â”œâ”€â”€ portfolio_balance_node.py   # ç»„åˆå¹³è¡¡
â”‚   â”‚   â””â”€â”€ timing_decision_node.py     # æ—¶æœºå†³ç­–
â”‚   â””â”€â”€ output/                         # è¾“å‡ºèŠ‚ç‚¹
â”‚       â”œâ”€â”€ report_generation_node.py   # æŠ¥å‘Šç”Ÿæˆ
â”‚       â”œâ”€â”€ alert_notification_node.py  # å‘Šè­¦é€šçŸ¥
â”‚       â”œâ”€â”€ recommendation_node.py      # æ¨èå»ºè®®
â”‚       â””â”€â”€ visualization_node.py       # å¯è§†åŒ–è¾“å‡º
â”œâ”€â”€ core_services/                       # ğŸ†• æ ¸å¿ƒæœåŠ¡å±‚
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ llm_service/                    # LLMæœåŠ¡
â”‚   â”‚   â”œâ”€â”€ llm_client_factory.py       # LLMå®¢æˆ·ç«¯å·¥å‚
â”‚   â”‚   â”œâ”€â”€ qwen_client.py              # åƒé—®å®¢æˆ·ç«¯
â”‚   â”‚   â”œâ”€â”€ prompt_manager.py           # æç¤ºè¯ç®¡ç†
â”‚   â”‚   â””â”€â”€ response_parser.py          # å“åº”è§£æå™¨
â”‚   â”œâ”€â”€ vector_service/                 # å‘é‡æ•°æ®åº“æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ chroma_client.py            # ChromaDBå®¢æˆ·ç«¯
â”‚   â”‚   â”œâ”€â”€ embedding_service.py        # åµŒå…¥å‘é‡æœåŠ¡
â”‚   â”‚   â””â”€â”€ similarity_search.py        # ç›¸ä¼¼æ€§æœç´¢
â”‚   â”œâ”€â”€ cache_service/                  # ç¼“å­˜æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ redis_cache.py              # Redisç¼“å­˜
â”‚   â”‚   â”œâ”€â”€ memory_cache.py             # å†…å­˜ç¼“å­˜
â”‚   â”‚   â””â”€â”€ cache_strategy.py           # ç¼“å­˜ç­–ç•¥
â”‚   â””â”€â”€ monitoring_service/             # ç›‘æ§æœåŠ¡
â”‚       â”œâ”€â”€ metrics_collector.py        # æŒ‡æ ‡æ”¶é›†å™¨
â”‚       â”œâ”€â”€ performance_monitor.py      # æ€§èƒ½ç›‘æ§
â”‚       â””â”€â”€ alert_manager.py            # å‘Šè­¦ç®¡ç†
â”œâ”€â”€ utils/                               # ğŸ”„ æ‰©å±•ï¼šé€šç”¨å·¥å…·å±‚
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ data_validator.py               # æ•°æ®éªŒè¯å™¨
â”‚   â”œâ”€â”€ result_formatter.py             # ç»“æœæ ¼å¼åŒ–å™¨
â”‚   â”œâ”€â”€ configuration_loader.py         # é…ç½®åŠ è½½å™¨
â”‚   â”œâ”€â”€ security_utils.py               # å®‰å…¨å·¥å…·
â”‚   â””â”€â”€ async_utils.py                  # å¼‚æ­¥å·¥å…·
â””â”€â”€ interfaces/                          # ğŸ†• æ¥å£å®šä¹‰å±‚
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ agent_interface.py              # ä»£ç†æ¥å£
    â”œâ”€â”€ flow_interface.py               # æµç¨‹æ¥å£
    â”œâ”€â”€ node_interface.py               # èŠ‚ç‚¹æ¥å£
    â””â”€â”€ service_interface.py            # æœåŠ¡æ¥å£
```

## ğŸ¤– ä»£ç†ç®¡ç†å±‚ (Agent Manager Layer)

### 1. ä»£ç†æ³¨å†Œè¡¨ (Agent Registry)

[core/ai_agents/agent_manager/agent_registry.py](mdc:core/ai_agents/agent_manager/agent_registry.py)
```python
from typing import Dict, Type, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
from ..interfaces.agent_interface import BaseAgent

class AgentCategory(Enum):
    """ä»£ç†åˆ†ç±»"""
    ANALYSIS = "analysis"          # åˆ†æç±»ä»£ç†
    ADVISORY = "advisory"          # å’¨è¯¢ç±»ä»£ç†  
    MONITORING = "monitoring"      # ç›‘æ§ç±»ä»£ç†
    OPTIMIZATION = "optimization"  # ä¼˜åŒ–ç±»ä»£ç†
    REPORTING = "reporting"        # æŠ¥å‘Šç±»ä»£ç†

@dataclass
class AgentMetadata:
    """ä»£ç†å…ƒæ•°æ®"""
    name: str
    description: str
    category: AgentCategory
    version: str
    capabilities: List[str]
    dependencies: List[str]
    input_schemas: Dict[str, Any]
    output_schemas: Dict[str, Any]
    performance_requirements: Dict[str, Any]

class AgentRegistry:
    """ä»£ç†æ³¨å†Œè¡¨ - ç®¡ç†æ‰€æœ‰å¯ç”¨çš„AIä»£ç†"""
    
    def __init__(self):
        self._agents: Dict[str, Type[BaseAgent]] = {}
        self._metadata: Dict[str, AgentMetadata] = {}
        self._categories: Dict[AgentCategory, List[str]] = {
            category: [] for category in AgentCategory
        }
    
    def register_agent(self, agent_name: str, agent_class: Type[BaseAgent], 
                      metadata: AgentMetadata) -> None:
        """æ³¨å†Œæ–°ä»£ç†"""
        self._agents[agent_name] = agent_class
        self._metadata[agent_name] = metadata
        self._categories[metadata.category].append(agent_name)
    
    def get_agent_class(self, agent_name: str) -> Optional[Type[BaseAgent]]:
        """è·å–ä»£ç†ç±»"""
        return self._agents.get(agent_name)
    
    def get_agents_by_category(self, category: AgentCategory) -> List[str]:
        """æŒ‰åˆ†ç±»è·å–ä»£ç†åˆ—è¡¨"""
        return self._categories.get(category, [])
    
    def get_agent_capabilities(self, agent_name: str) -> List[str]:
        """è·å–ä»£ç†èƒ½åŠ›åˆ—è¡¨"""
        metadata = self._metadata.get(agent_name)
        return metadata.capabilities if metadata else []
    
    def find_agents_by_capability(self, capability: str) -> List[str]:
        """æ ¹æ®èƒ½åŠ›æŸ¥æ‰¾ä»£ç†"""
        matching_agents = []
        for agent_name, metadata in self._metadata.items():
            if capability in metadata.capabilities:
                matching_agents.append(agent_name)
        return matching_agents

# å…¨å±€ä»£ç†æ³¨å†Œè¡¨å®ä¾‹
agent_registry = AgentRegistry()
```

### 2. ä»£ç†å·¥å‚ (Agent Factory)

[core/ai_agents/agent_manager/agent_factory.py](mdc:core/ai_agents/agent_manager/agent_factory.py)
```python
from typing import Dict, Any, Optional
from .agent_registry import agent_registry, AgentCategory
from .agent_config import AgentConfigManager
from ..interfaces.agent_interface import BaseAgent
from ..core_services.llm_service.llm_client_factory import LLMClientFactory
from ..core_services.vector_service.chroma_client import ChromaClient

class AgentFactory:
    """ä»£ç†å·¥å‚ - è´Ÿè´£åˆ›å»ºå’Œé…ç½®AIä»£ç†å®ä¾‹"""
    
    def __init__(self):
        self.config_manager = AgentConfigManager()
        self.llm_factory = LLMClientFactory()
        self.vector_client = ChromaClient()
    
    def create_agent(self, agent_name: str, 
                    config_override: Optional[Dict[str, Any]] = None) -> BaseAgent:
        """åˆ›å»ºä»£ç†å®ä¾‹"""
        
        # è·å–ä»£ç†ç±»
        agent_class = agent_registry.get_agent_class(agent_name)
        if not agent_class:
            raise ValueError(f"æœªçŸ¥çš„ä»£ç†ç±»å‹: {agent_name}")
        
        # åŠ è½½é…ç½®
        agent_config = self.config_manager.get_agent_config(agent_name)
        if config_override:
            agent_config.update(config_override)
        
        # åˆ›å»ºä¾èµ–æœåŠ¡
        llm_client = self.llm_factory.create_client(
            agent_config.get("llm_provider", "qwen")
        )
        
        # å®ä¾‹åŒ–ä»£ç†
        agent_instance = agent_class(
            config=agent_config,
            llm_client=llm_client,
            vector_client=self.vector_client
        )
        
        return agent_instance
    
    def create_agent_pipeline(self, agent_names: List[str], 
                            pipeline_config: Dict[str, Any]) -> 'AgentPipeline':
        """åˆ›å»ºä»£ç†ç®¡é“"""
        agents = []
        for agent_name in agent_names:
            agent = self.create_agent(agent_name)
            agents.append(agent)
        
        return AgentPipeline(agents, pipeline_config)
    
    def get_recommended_agents(self, task_description: str, 
                             requirements: Dict[str, Any]) -> List[str]:
        """æ ¹æ®ä»»åŠ¡æè¿°æ¨èåˆé€‚çš„ä»£ç†"""
        # åŸºäºä»»åŠ¡æè¿°å’Œéœ€æ±‚ï¼Œä½¿ç”¨LLMæ¨èåˆé€‚çš„ä»£ç†ç»„åˆ
        recommended_agents = self._llm_recommend_agents(
            task_description, requirements
        )
        return recommended_agents

# å…¨å±€ä»£ç†å·¥å‚å®ä¾‹
agent_factory = AgentFactory()
```

### 3. ä»£ç†ç¼–æ’å™¨ (Agent Orchestrator)

[core/ai_agents/agent_manager/agent_orchestrator.py](mdc:core/ai_agents/agent_manager/agent_orchestrator.py)
```python
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum
import asyncio
from datetime import datetime

class OrchestrationMode(Enum):
    """ç¼–æ’æ¨¡å¼"""
    SEQUENTIAL = "sequential"      # é¡ºåºæ‰§è¡Œ
    PARALLEL = "parallel"          # å¹¶è¡Œæ‰§è¡Œ
    CONDITIONAL = "conditional"    # æ¡ä»¶æ‰§è¡Œ
    ITERATIVE = "iterative"        # è¿­ä»£æ‰§è¡Œ

@dataclass
class TaskContext:
    """ä»»åŠ¡ä¸Šä¸‹æ–‡"""
    task_id: str
    user_id: str
    task_type: str
    input_data: Dict[str, Any]
    requirements: Dict[str, Any]
    context_data: Dict[str, Any]
    created_at: datetime

class AgentOrchestrator:
    """ä»£ç†ç¼–æ’å™¨ - åè°ƒå¤šä¸ªAIä»£ç†åä½œå®Œæˆå¤æ‚ä»»åŠ¡"""
    
    def __init__(self):
        self.agent_factory = agent_factory
        self.active_tasks: Dict[str, TaskContext] = {}
        self.task_results: Dict[str, Dict[str, Any]] = {}
    
    async def execute_task(self, task_context: TaskContext, 
                          orchestration_plan: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡Œå¤æ‚ä»»åŠ¡"""
        task_id = task_context.task_id
        self.active_tasks[task_id] = task_context
        
        try:
            mode = OrchestrationMode(orchestration_plan.get("mode", "sequential"))
            
            if mode == OrchestrationMode.SEQUENTIAL:
                result = await self._execute_sequential(task_context, orchestration_plan)
            elif mode == OrchestrationMode.PARALLEL:
                result = await self._execute_parallel(task_context, orchestration_plan)
            elif mode == OrchestrationMode.CONDITIONAL:
                result = await self._execute_conditional(task_context, orchestration_plan)
            elif mode == OrchestrationMode.ITERATIVE:
                result = await self._execute_iterative(task_context, orchestration_plan)
            else:
                raise ValueError(f"ä¸æ”¯æŒçš„ç¼–æ’æ¨¡å¼: {mode}")
            
            self.task_results[task_id] = result
            return result
            
        finally:
            # æ¸…ç†ä»»åŠ¡ä¸Šä¸‹æ–‡
            if task_id in self.active_tasks:
                del self.active_tasks[task_id]
    
    async def _execute_sequential(self, task_context: TaskContext, 
                                plan: Dict[str, Any]) -> Dict[str, Any]:
        """é¡ºåºæ‰§è¡Œå¤šä¸ªä»£ç†"""
        agents = plan["agents"]
        context_data = task_context.context_data.copy()
        results = {}
        
        for step_config in agents:
            agent_name = step_config["agent"]
            agent_config = step_config.get("config", {})
            
            # åˆ›å»ºä»£ç†å®ä¾‹
            agent = self.agent_factory.create_agent(agent_name, agent_config)
            
            # æ‰§è¡Œä»£ç†ä»»åŠ¡
            step_result = await agent.execute_async(
                input_data=context_data,
                task_context=task_context
            )
            
            # æ›´æ–°ä¸Šä¸‹æ–‡æ•°æ®
            context_data.update(step_result.get("context_updates", {}))
            results[agent_name] = step_result
        
        return {
            "mode": "sequential",
            "agent_results": results,
            "final_context": context_data,
            "task_id": task_context.task_id
        }
    
    async def _execute_parallel(self, task_context: TaskContext, 
                              plan: Dict[str, Any]) -> Dict[str, Any]:
        """å¹¶è¡Œæ‰§è¡Œå¤šä¸ªä»£ç†"""
        agents = plan["agents"]
        tasks = []
        
        for step_config in agents:
            agent_name = step_config["agent"]
            agent_config = step_config.get("config", {})
            
            # åˆ›å»ºä»£ç†å®ä¾‹
            agent = self.agent_factory.create_agent(agent_name, agent_config)
            
            # åˆ›å»ºå¼‚æ­¥ä»»åŠ¡
            task = asyncio.create_task(
                agent.execute_async(
                    input_data=task_context.context_data,
                    task_context=task_context
                )
            )
            tasks.append((agent_name, task))
        
        # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        results = {}
        for agent_name, task in tasks:
            try:
                result = await task
                results[agent_name] = result
            except Exception as e:
                results[agent_name] = {"error": str(e), "success": False}
        
        return {
            "mode": "parallel",
            "agent_results": results,
            "task_id": task_context.task_id
        }

# å…¨å±€ä»£ç†ç¼–æ’å™¨å®ä¾‹
agent_orchestrator = AgentOrchestrator()
```

## ğŸ¯ é€šç”¨ä»£ç†åŸºç±» (Base Agent)

### ä»£ç†æ¥å£å®šä¹‰

[core/ai_agents/interfaces/agent_interface.py](mdc:core/ai_agents/interfaces/agent_interface.py)
```python
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from datetime import datetime

@dataclass
class AgentExecutionResult:
    """ä»£ç†æ‰§è¡Œç»“æœ"""
    success: bool
    result_data: Dict[str, Any]
    context_updates: Dict[str, Any]
    execution_time: float
    error_message: Optional[str] = None
    confidence_score: Optional[float] = None
    recommendations: List[str] = None

class BaseAgent(ABC):
    """AIä»£ç†åŸºç±»æ¥å£"""
    
    def __init__(self, config: Dict[str, Any], llm_client: Any, 
                 vector_client: Any):
        self.config = config
        self.llm_client = llm_client
        self.vector_client = vector_client
        self.execution_metrics = {
            "total_executions": 0,
            "successful_executions": 0,
            "average_execution_time": 0.0,
            "last_execution": None
        }
    
    @abstractmethod
    async def execute_async(self, input_data: Dict[str, Any], 
                           task_context: Optional[Any] = None) -> AgentExecutionResult:
        """å¼‚æ­¥æ‰§è¡Œä»£ç†ä»»åŠ¡"""
        pass
    
    @abstractmethod
    def get_capabilities(self) -> List[str]:
        """è·å–ä»£ç†èƒ½åŠ›åˆ—è¡¨"""
        pass
    
    @abstractmethod
    def validate_input(self, input_data: Dict[str, Any]) -> bool:
        """éªŒè¯è¾“å…¥æ•°æ®"""
        pass
    
    def get_execution_metrics(self) -> Dict[str, Any]:
        """è·å–æ‰§è¡ŒæŒ‡æ ‡"""
        return self.execution_metrics.copy()
```

### é€šç”¨ä»£ç†å®ç°åŸºç±»

[core/ai_agents/agents/base_agent.py](mdc:core/ai_agents/agents/base_agent.py)
```python
from typing import Dict, Any, List, Optional
from datetime import datetime
import logging
from ..interfaces.agent_interface import BaseAgent, AgentExecutionResult

logger = logging.getLogger(__name__)

class UniversalAgent(BaseAgent):
    """é€šç”¨AIä»£ç†åŸºç±»å®ç°"""
    
    def __init__(self, config: Dict[str, Any], llm_client: Any, 
                 vector_client: Any):
        super().__init__(config, llm_client, vector_client)
        self.agent_name = config.get("agent_name", self.__class__.__name__)
        self.capabilities = config.get("capabilities", [])
        self.max_retries = config.get("max_retries", 3)
        self.timeout = config.get("timeout", 300)
    
    async def execute_async(self, input_data: Dict[str, Any], 
                           task_context: Optional[Any] = None) -> AgentExecutionResult:
        """é€šç”¨å¼‚æ­¥æ‰§è¡Œæ¡†æ¶"""
        start_time = datetime.now()
        
        try:
            # 1. è¾“å…¥éªŒè¯
            if not self.validate_input(input_data):
                raise ValueError("è¾“å…¥æ•°æ®éªŒè¯å¤±è´¥")
            
            # 2. é¢„å¤„ç†
            processed_data = await self.preprocess_data(input_data, task_context)
            
            # 3. æ ¸å¿ƒæ‰§è¡Œ
            result_data = await self.execute_core_logic(processed_data, task_context)
            
            # 4. åå¤„ç†
            final_result = await self.postprocess_result(result_data, task_context)
            
            # 5. æ›´æ–°æŒ‡æ ‡
            execution_time = (datetime.now() - start_time).total_seconds()
            self._update_metrics(True, execution_time)
            
            return AgentExecutionResult(
                success=True,
                result_data=final_result,
                context_updates=self.get_context_updates(final_result),
                execution_time=execution_time,
                confidence_score=self.calculate_confidence(final_result),
                recommendations=self.generate_recommendations(final_result)
            )
            
        except Exception as e:
            execution_time = (datetime.now() - start_time).total_seconds()
            self._update_metrics(False, execution_time)
            
            logger.error(f"{self.agent_name} æ‰§è¡Œå¤±è´¥: {e}")
            
            return AgentExecutionResult(
                success=False,
                result_data={},
                context_updates={},
                execution_time=execution_time,
                error_message=str(e)
            )
    
    @abstractmethod
    async def execute_core_logic(self, processed_data: Dict[str, Any], 
                               task_context: Optional[Any]) -> Dict[str, Any]:
        """æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ - å­ç±»å¿…é¡»å®ç°"""
        pass
    
    async def preprocess_data(self, input_data: Dict[str, Any], 
                            task_context: Optional[Any]) -> Dict[str, Any]:
        """æ•°æ®é¢„å¤„ç† - å­ç±»å¯é€‰é‡å†™"""
        return input_data
    
    async def postprocess_result(self, result_data: Dict[str, Any], 
                               task_context: Optional[Any]) -> Dict[str, Any]:
        """ç»“æœåå¤„ç† - å­ç±»å¯é€‰é‡å†™"""
        return result_data
    
    def get_context_updates(self, result_data: Dict[str, Any]) -> Dict[str, Any]:
        """è·å–ä¸Šä¸‹æ–‡æ›´æ–° - å­ç±»å¯é€‰é‡å†™"""
        return {}
    
    def calculate_confidence(self, result_data: Dict[str, Any]) -> float:
        """è®¡ç®—ç½®ä¿¡åº¦ - å­ç±»å¯é€‰é‡å†™"""
        return 0.8
    
    def generate_recommendations(self, result_data: Dict[str, Any]) -> List[str]:
        """ç”Ÿæˆæ¨èå»ºè®® - å­ç±»å¯é€‰é‡å†™"""
        return []
    
    def get_capabilities(self) -> List[str]:
        """è·å–ä»£ç†èƒ½åŠ›"""
        return self.capabilities
    
    def validate_input(self, input_data: Dict[str, Any]) -> bool:
        """åŸºç¡€è¾“å…¥éªŒè¯"""
        return isinstance(input_data, dict)
    
    def _update_metrics(self, success: bool, execution_time: float):
        """æ›´æ–°æ‰§è¡ŒæŒ‡æ ‡"""
        self.execution_metrics["total_executions"] += 1
        if success:
            self.execution_metrics["successful_executions"] += 1
        
        # æ›´æ–°å¹³å‡æ‰§è¡Œæ—¶é—´
        total = self.execution_metrics["total_executions"]
        current_avg = self.execution_metrics["average_execution_time"]
        self.execution_metrics["average_execution_time"] = (
            (current_avg * (total - 1) + execution_time) / total
        )
        
        self.execution_metrics["last_execution"] = datetime.now()
```

## ğŸ”„ ä¸šåŠ¡ä»£ç†ç¤ºä¾‹

### è‚¡ç¥¨åˆ†æä»£ç†

[core/ai_agents/agents/stock_analysis_agent.py](mdc:core/ai_agents/agents/stock_analysis_agent.py)
```python
from typing import Dict, Any, List, Optional
from .base_agent import UniversalAgent
from core.data_providers.stock_data_factory import get_stock_quote, get_stock_info
from core.handler.ticker_score_handler import TickerScoreHandler

class StockAnalysisAgent(UniversalAgent):
    """è‚¡ç¥¨åˆ†æä»£ç† - ä¸“é—¨å¤„ç†è‚¡ç¥¨ç›¸å…³çš„æ™ºèƒ½åˆ†æ"""
    
    def __init__(self, config: Dict[str, Any], llm_client: Any, vector_client: Any):
        super().__init__(config, llm_client, vector_client)
        self.score_handler = TickerScoreHandler()
        self.analysis_types = config.get("analysis_types", ["technical", "fundamental"])
    
    async def execute_core_logic(self, processed_data: Dict[str, Any], 
                               task_context: Optional[Any]) -> Dict[str, Any]:
        """æ‰§è¡Œè‚¡ç¥¨åˆ†ææ ¸å¿ƒé€»è¾‘"""
        stock_codes = processed_data.get("stock_codes", [])
        analysis_type = processed_data.get("analysis_type", "comprehensive")
        
        analysis_results = []
        
        for stock_code in stock_codes:
            # è·å–è‚¡ç¥¨åŸºç¡€ä¿¡æ¯
            stock_info = get_stock_info(stock_code)
            if not stock_info:
                continue
            
            # è·å–å®æ—¶è¡Œæƒ…
            stock_quote = get_stock_quote(stock_code)
            
            # æ‰§è¡Œä¸åŒç±»å‹çš„åˆ†æ
            stock_analysis = {
                "stock_code": stock_code,
                "stock_info": stock_info,
                "current_quote": stock_quote
            }
            
            if "technical" in self.analysis_types:
                stock_analysis["technical_analysis"] = await self._technical_analysis(
                    stock_code, stock_quote
                )
            
            if "fundamental" in self.analysis_types:
                stock_analysis["fundamental_analysis"] = await self._fundamental_analysis(
                    stock_code, stock_info
                )
            
            if "sentiment" in self.analysis_types:
                stock_analysis["sentiment_analysis"] = await self._sentiment_analysis(
                    stock_code
                )
            
            # ç»¼åˆè¯„åˆ†
            stock_analysis["overall_score"] = await self._calculate_overall_score(
                stock_analysis
            )
            
            analysis_results.append(stock_analysis)
        
        return {
            "analysis_type": analysis_type,
            "analyzed_stocks": analysis_results,
            "summary": self._generate_summary(analysis_results)
        }
    
    async def _technical_analysis(self, stock_code: str, 
                                stock_quote: Dict[str, Any]) -> Dict[str, Any]:
        """æŠ€æœ¯åˆ†æ"""
        # ä½¿ç”¨LLMè¿›è¡ŒæŠ€æœ¯æŒ‡æ ‡åˆ†æ
        prompt = f"""
        åˆ†æè‚¡ç¥¨ {stock_code} çš„æŠ€æœ¯æŒ‡æ ‡ï¼š
        å½“å‰ä»·æ ¼: {stock_quote.get('current_price')}
        æ¶¨è·Œå¹…: {stock_quote.get('change_percent')}
        
        è¯·åˆ†ææŠ€æœ¯è¶‹åŠ¿å¹¶ç»™å‡ºè¯„åˆ†ã€‚
        """
        
        response = await self.llm_client.chat_completion_async([
            {"role": "user", "content": prompt}
        ])
        
        return {
            "trend_direction": "ä¸Šæ¶¨/ä¸‹è·Œ/æ¨ªç›˜",
            "support_level": 0.0,
            "resistance_level": 0.0,
            "technical_score": 0.8,
            "analysis_detail": response.get("content", "")
        }
    
    def get_capabilities(self) -> List[str]:
        """è‚¡ç¥¨åˆ†æä»£ç†çš„èƒ½åŠ›"""
        return [
            "technical_analysis",       # æŠ€æœ¯åˆ†æ
            "fundamental_analysis",     # åŸºæœ¬é¢åˆ†æ  
            "sentiment_analysis",       # æƒ…æ„Ÿåˆ†æ
            "stock_scoring",           # è‚¡ç¥¨è¯„åˆ†
            "trend_prediction",        # è¶‹åŠ¿é¢„æµ‹
            "risk_assessment",         # é£é™©è¯„ä¼°
            "portfolio_analysis"       # ç»„åˆåˆ†æ
        ]
    
    def validate_input(self, input_data: Dict[str, Any]) -> bool:
        """éªŒè¯è‚¡ç¥¨åˆ†æè¾“å…¥"""
        if not super().validate_input(input_data):
            return False
        
        # å¿…é¡»åŒ…å«è‚¡ç¥¨ä»£ç 
        stock_codes = input_data.get("stock_codes")
        if not stock_codes or not isinstance(stock_codes, list):
            return False
        
        return True
```

### æ–°é—»åˆ†æä»£ç†

[core/ai_agents/agents/news_analysis_agent.py](mdc:core/ai_agents/agents/news_analysis_agent.py)  
```python
from typing import Dict, Any, List, Optional
from .base_agent import UniversalAgent
from core.models.news_article import NewsArticle

class NewsAnalysisAgent(UniversalAgent):
    """æ–°é—»åˆ†æä»£ç† - ä¸“é—¨å¤„ç†æ–°é—»ç›¸å…³çš„æ™ºèƒ½åˆ†æ"""
    
    def __init__(self, config: Dict[str, Any], llm_client: Any, vector_client: Any):
        super().__init__(config, llm_client, vector_client)
        self.analysis_depth = config.get("analysis_depth", "standard")
        self.extract_stocks = config.get("extract_stocks", True)
    
    async def execute_core_logic(self, processed_data: Dict[str, Any], 
                               task_context: Optional[Any]) -> Dict[str, Any]:
        """æ‰§è¡Œæ–°é—»åˆ†ææ ¸å¿ƒé€»è¾‘"""
        articles = processed_data.get("articles", [])
        analysis_focus = processed_data.get("analysis_focus", "general")
        
        analysis_results = []
        
        for article in articles:
            article_analysis = await self._analyze_single_article(
                article, analysis_focus
            )
            analysis_results.append(article_analysis)
        
        # ç»¼åˆåˆ†æ
        comprehensive_analysis = await self._comprehensive_analysis(
            analysis_results
        )
        
        return {
            "individual_analyses": analysis_results,
            "comprehensive_analysis": comprehensive_analysis,
            "market_sentiment": self._extract_market_sentiment(analysis_results),
            "investment_implications": self._extract_investment_implications(analysis_results)
        }
    
    async def _analyze_single_article(self, article: NewsArticle, 
                                    focus: str) -> Dict[str, Any]:
        """åˆ†æå•ç¯‡æ–‡ç« """
        
        # æ„å»ºåˆ†ææç¤ºè¯
        prompt = f"""
        åˆ†æä»¥ä¸‹æ–°é—»æ–‡ç« ï¼Œé‡ç‚¹å…³æ³¨ {focus}ï¼š
        
        æ ‡é¢˜: {article.title}
        å†…å®¹: {article.content[:2000]}...
        
        è¯·åˆ†æï¼š
        1. æ–‡ç« ä¸»è¦ä¸»é¢˜å’Œå…³é”®ä¿¡æ¯
        2. æ¶‰åŠçš„è‚¡ç¥¨æˆ–è¡Œä¸š
        3. å¸‚åœºæƒ…æ„Ÿå€¾å‘
        4. æŠ•èµ„ç›¸å…³æ€§
        5. é‡è¦æ€§è¯„åˆ† (1-10)
        """
        
        response = await self.llm_client.chat_completion_async([
            {"role": "user", "content": prompt}
        ])
        
        # ä½¿ç”¨å‘é‡æ•°æ®åº“æŸ¥æ‰¾ç›¸ä¼¼æ–‡ç« 
        similar_articles = await self._find_similar_articles(article)
        
        return {
            "article_id": article.id,
            "main_theme": "ä¸»é¢˜æå–",
            "mentioned_stocks": await self._extract_stocks(article) if self.extract_stocks else [],
            "sentiment_score": 0.6,  # -1 åˆ° 1
            "importance_score": 7,   # 1 åˆ° 10
            "investment_relevance": "é«˜/ä¸­/ä½",
            "similar_articles": similar_articles,
            "detailed_analysis": response.get("content", "")
        }
    
    def get_capabilities(self) -> List[str]:
        """æ–°é—»åˆ†æä»£ç†çš„èƒ½åŠ›"""
        return [
            "sentiment_analysis",      # æƒ…æ„Ÿåˆ†æ
            "topic_extraction",        # ä¸»é¢˜æå–
            "stock_mention_detection", # è‚¡ç¥¨æåŠæ£€æµ‹
            "importance_scoring",      # é‡è¦æ€§è¯„åˆ†
            "trend_identification",    # è¶‹åŠ¿è¯†åˆ«
            "market_impact_analysis",  # å¸‚åœºå½±å“åˆ†æ
            "content_summarization"    # å†…å®¹æ‘˜è¦
        ]
```

## ğŸ“Š ç›‘æ§å’Œæ€§èƒ½è§„èŒƒ

### ä»£ç†æ€§èƒ½ç›‘æ§

```python
class AgentPerformanceMonitor:
    """ä»£ç†æ€§èƒ½ç›‘æ§å™¨"""
    
    def __init__(self):
        self.metrics = {}
        self.alert_thresholds = {
            "max_execution_time": 300,  # æœ€å¤§æ‰§è¡Œæ—¶é—´ï¼ˆç§’ï¼‰
            "min_success_rate": 0.95,   # æœ€å°æˆåŠŸç‡
            "max_error_rate": 0.05      # æœ€å¤§é”™è¯¯ç‡
        }
    
    def record_execution(self, agent_name: str, result: AgentExecutionResult):
        """è®°å½•ä»£ç†æ‰§è¡Œç»“æœ"""
        if agent_name not in self.metrics:
            self.metrics[agent_name] = {
                "total_executions": 0,
                "successful_executions": 0,
                "total_execution_time": 0.0,
                "errors": []
            }
        
        metrics = self.metrics[agent_name]
        metrics["total_executions"] += 1
        
        if result.success:
            metrics["successful_executions"] += 1
        else:
            metrics["errors"].append({
                "timestamp": datetime.now(),
                "error": result.error_message
            })
        
        metrics["total_execution_time"] += result.execution_time
        
        # æ£€æŸ¥å‘Šè­¦æ¡ä»¶
        self._check_alerts(agent_name, metrics)
```

## ğŸš€ æœ€ä½³å®è·µ

### 1. ä»£ç†è®¾è®¡åŸåˆ™
- **å•ä¸€èŒè´£**: æ¯ä¸ªä»£ç†ä¸“æ³¨äºç‰¹å®šçš„ä¸šåŠ¡é¢†åŸŸ
- **å¯ç»„åˆæ€§**: ä»£ç†ä¹‹é—´å¯ä»¥çµæ´»ç»„åˆåä½œ
- **å¯é…ç½®æ€§**: é€šè¿‡é…ç½®æ–‡ä»¶è°ƒæ•´ä»£ç†è¡Œä¸º
- **å¯ç›‘æ§æ€§**: å†…ç½®å®Œæ•´çš„æ€§èƒ½å’Œé”™è¯¯ç›‘æ§

### 2. å¤šä»£ç†åä½œæ¨¡å¼
- **ç®¡é“æ¨¡å¼**: ä»£ç†æŒ‰é¡ºåºå¤„ç†æ•°æ®
- **å¹¶è¡Œæ¨¡å¼**: å¤šä¸ªä»£ç†åŒæ—¶å¤„ç†ä¸åŒæ–¹é¢
- **åˆ†å±‚æ¨¡å¼**: ä¸åŒå±‚æ¬¡çš„ä»£ç†å¤„ç†ä¸åŒæŠ½è±¡çº§åˆ«
- **åé¦ˆæ¨¡å¼**: ä»£ç†ä¹‹é—´ç›¸äº’æä¾›åé¦ˆå’Œè°ƒæ•´

### 3. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
- **ç¼“å­˜æœºåˆ¶**: ç¼“å­˜é‡å¤çš„LLMè°ƒç”¨ç»“æœ
- **æ‰¹å¤„ç†**: æ‰¹é‡å¤„ç†ç›¸ä¼¼çš„ä»»åŠ¡
- **å¼‚æ­¥æ‰§è¡Œ**: ä½¿ç”¨å¼‚æ­¥ç¼–ç¨‹æé«˜å¹¶å‘æ€§èƒ½
- **èµ„æºæ± åŒ–**: å¤ç”¨LLMå®¢æˆ·ç«¯å’Œæ•°æ®åº“è¿æ¥

è¿™ä¸ªé‡æ–°è®¾è®¡çš„é€šç”¨AIä»£ç†æ¶æ„ä¸å†å±€é™äºæ–°é—»åˆ†æï¼Œè€Œæ˜¯æä¾›äº†ä¸€ä¸ªå®Œæ•´çš„ã€å¯æ‰©å±•çš„AIä»£ç†æ¡†æ¶ï¼Œèƒ½å¤Ÿæ”¯æŒæŠ•èµ„åˆ†æçš„æ‰€æœ‰ä¸šåŠ¡åœºæ™¯ã€‚
