---
description: 
globs: api/tests/**
alwaysApply: false
---
# FastAPI æµ‹è¯•è§„èŒƒ

## æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›äº†åœ¨ FastAPI é¡¹ç›®ä¸­ç¼–å†™å’Œç»„ç»‡æµ‹è¯•çš„æŒ‡å¯¼æ–¹é’ˆã€‚æœ‰æ•ˆçš„æµ‹è¯•æ˜¯ç¡®ä¿åº”ç”¨ç¨‹åºè´¨é‡ã€ç¨³å®šæ€§å’Œå¯ç»´æŠ¤æ€§çš„å…³é”®ã€‚

## æµ‹è¯•å·¥å…·

- **`pytest`**: æ¨èä½œä¸ºä¸»è¦çš„æµ‹è¯•æ¡†æ¶ï¼Œå› å…¶ç®€æ´çš„è¯­æ³•å’Œå¼ºå¤§çš„æ’ä»¶ç”Ÿæ€ç³»ç»Ÿã€‚
- **`pytest-asyncio`**: ç”¨äºæµ‹è¯•å¼‚æ­¥ä»£ç  (FastAPI ä¸­çš„ `async def` è·¯ç”±å’Œå‡½æ•°)ã€‚
- **`FastAPI.testclient.TestClient`**: FastAPI å†…ç½®çš„æµ‹è¯•å®¢æˆ·ç«¯ï¼Œç”¨äºå‘åº”ç”¨ç¨‹åºå‘é€ HTTP è¯·æ±‚å¹¶æ£€æŸ¥å“åº”ï¼Œåº•å±‚åŸºäº `httpx`ã€‚
- **`Faker`**: ç”¨äºç”Ÿæˆä¼ªé€ æ•°æ®ï¼Œä½¿æµ‹è¯•æ›´çœŸå®ä¸”å¤šæ ·åŒ–ã€‚
- **è¦†ç›–ç‡å·¥å…· (`coverage.py` + `pytest-cov`)**: ç”¨äºè¡¡é‡æµ‹è¯•è¦†ç›–ç‡ã€‚

## æµ‹è¯•ç±»å‹

æ ¹æ®æµ‹è¯•é‡‘å­—å¡”æ¨¡å‹ï¼Œä¸»è¦å…³æ³¨ä»¥ä¸‹ç±»å‹çš„æµ‹è¯•ï¼š

1.  **å•å…ƒæµ‹è¯• (Unit Tests)**:
    *   æµ‹è¯•æœ€å°çš„å¯æµ‹è¯•å•å…ƒï¼ˆä¾‹å¦‚ï¼Œå•ä¸ªå‡½æ•°ã€æ–¹æ³•æˆ– Pydantic æ¨¡å‹éªŒè¯å™¨ï¼‰ã€‚
    *   åº”å¿«é€Ÿè¿è¡Œä¸”ä¸ä¾èµ–å¤–éƒ¨æœåŠ¡ï¼ˆå¦‚æ•°æ®åº“ã€ç½‘ç»œï¼‰ã€‚
    *   å¯¹ `services` ä¸­çš„ä¸šåŠ¡é€»è¾‘å•å…ƒã€Pydantic æ¨¡å‹çš„è‡ªå®šä¹‰éªŒè¯å™¨ç­‰è¿›è¡Œå•å…ƒæµ‹è¯•ã€‚

2.  **é›†æˆæµ‹è¯• (Integration Tests)**:
    *   æµ‹è¯•å¤šä¸ªç»„ä»¶ä¹‹é—´çš„äº¤äº’ã€‚
    *   ä¾‹å¦‚ï¼Œæµ‹è¯• API ç«¯ç‚¹ä¸å…¶ä¾èµ–çš„æœåŠ¡å’Œæ•°æ®åº“æ“ä½œæ˜¯å¦æ­£ç¡®é›†æˆã€‚
    *   å¯ä»¥ä½¿ç”¨ `TestClient` å‘é€è¯·æ±‚ï¼Œå¹¶éªŒè¯å“åº”ã€æ•°æ®åº“çŠ¶æ€å˜åŒ–ç­‰ã€‚

3.  **ç«¯åˆ°ç«¯æµ‹è¯• (End-to-End Tests)** (å¯é€‰ï¼Œæ ¹æ®é¡¹ç›®è§„æ¨¡å’Œéœ€æ±‚):
    *   æ¨¡æ‹ŸçœŸå®ç”¨æˆ·åœºæ™¯ï¼Œæµ‹è¯•æ•´ä¸ªåº”ç”¨ç¨‹åºæµç¨‹ã€‚
    *   é€šå¸¸è¾ƒæ…¢ï¼Œä¸”å¯èƒ½éœ€è¦æ›´å¤æ‚çš„è®¾ç½®ã€‚

## æµ‹è¯•ç»„ç»‡

- **`tests/` ç›®å½•**: æ‰€æœ‰æµ‹è¯•ä»£ç åº”æ”¾åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹çš„ `tests/` æ–‡ä»¶å¤¹ä¸­ã€‚
- **ç›®å½•ç»“æ„**: `tests/` å†…éƒ¨çš„ç›®å½•ç»“æ„åº”å°½å¯èƒ½æ¨¡ä»¿é¡¹ç›®ç»“æ„ï¼Œä»¥ä¾¿äºå®šä½æµ‹è¯•ã€‚
    ```
    tests/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ conftest.py         # Pytest å…±äº« fixtures å’Œé…ç½®
    â”œâ”€â”€ unit/
    â”‚   â”œâ”€â”€ test_models.py          # æµ‹è¯• Pydantic æ¨¡å‹
    â”‚   â”œâ”€â”€ test_repositories.py    # æµ‹è¯• Repository å±‚
    â”‚   â””â”€â”€ test_handlers/          # æµ‹è¯• Handler å±‚
    â”‚       â””â”€â”€ test_ticker_handler.py
    â”œâ”€â”€ integration/
    â”‚   â”œâ”€â”€ api/                    # API è·¯ç”±é›†æˆæµ‹è¯•
    â”‚   â”œâ”€â”€ services/               # æœåŠ¡å±‚é›†æˆæµ‹è¯•
    â”‚   â””â”€â”€ database/               # æ•°æ®åº“é›†æˆæµ‹è¯•
    â””â”€â”€ debug/                      # è°ƒè¯•å’Œå¼€å‘è¾…åŠ©æµ‹è¯•
        â””â”€â”€ test_development_helpers.py
    ```
- **æ–‡ä»¶å‘½å**: æµ‹è¯•æ–‡ä»¶ååº”ä»¥ `test_` å¼€å¤´ï¼Œå¯¹åº”è¢«æµ‹è¯•çš„æ¨¡å—å
- **APIæ¨¡å—æµ‹è¯•**: é’ˆå¯¹[api/routers/](mdc:api/routers)ä¸‹çš„æ¯ä¸ªè·¯ç”±æ¨¡å—åˆ›å»ºå¯¹åº”æµ‹è¯•æ–‡ä»¶

## ç¼–å†™æµ‹è¯•

### 1. ä½¿ç”¨ `TestClient`

```python
from fastapi.testclient import TestClient
from api.api import app  # ä»æ¨¡å—åŒ–çš„APIä¸»åº”ç”¨å¯¼å…¥

client = TestClient(app)

def test_read_main():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"message": "InvestNote API Service"}

# æµ‹è¯•è‚¡ç¥¨ç›¸å…³API
def test_get_ticker_pages():
    request_data = {"page": 1, "page_size": 20}
    response = client.post("/pages", json=request_data)
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "success"
    assert "data" in data

# æµ‹è¯•æ–°é—»ç›¸å…³API  
def test_get_news_sources():
    response = client.get("/news/sources")
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "success"
    assert isinstance(data["data"], list)

### 2. æµ‹è¯•å¼‚æ­¥ä»£ç 

éœ€è¦å®‰è£… `pytest-asyncio`ã€‚

```python
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

@pytest.mark.asyncio
async def test_async_endpoint():
    # å¯¹äº TestClientï¼Œå³ä½¿æ˜¯å¼‚æ­¥è·¯å¾„ï¼Œè°ƒç”¨ä¹Ÿæ˜¯åŒæ­¥çš„
    # TestClient å†…éƒ¨ä¼šå¤„ç†å¼‚æ­¥äº‹ä»¶å¾ªç¯
    response = client.get("/async_path")
    assert response.status_code == 200
    # å¦‚æœç›´æ¥æµ‹è¯•å¼‚æ­¥å‡½æ•°ï¼ˆéé€šè¿‡ TestClient çš„ HTTP è¯·æ±‚ï¼‰:
    # result = await your_async_function()
    # assert result == expected_value
```

### 3. Fixtures (`conftest.py`)

ä½¿ç”¨ `pytest`çš„ fixtures æ¥è®¾ç½®å’Œæ‹†å¸æµ‹è¯•ç¯å¢ƒã€æä¾›æµ‹è¯•æ•°æ®æˆ–æ¨¡æ‹Ÿä¾èµ–ã€‚

**`tests/conftest.py` ç¤ºä¾‹:**
```python
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.main import app
from app.core.config import settings
from app.database import Base, get_db # å‡è®¾ä½ çš„æ•°æ®åº“è®¾ç½®å’Œ get_db ä¾èµ–

# ä½¿ç”¨æµ‹è¯•æ•°æ®åº“é…ç½®
SQLALCHEMY_DATABASE_URL_TEST = settings.DATABASE_URL + "_test"

engine_test = create_engine(SQLALCHEMY_DATABASE_URL_TEST)
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine_test)

@pytest.fixture(scope="session", autouse=True)
def setup_test_db():
    Base.metadata.drop_all(bind=engine_test) # æ¸…ç†æ—§è¡¨
    Base.metadata.create_all(bind=engine_test) # åˆ›å»ºæ–°è¡¨
    yield
    Base.metadata.drop_all(bind=engine_test) # æµ‹è¯•åæ¸…ç†

@pytest.fixture(scope="function")
def db_session_test():
    connection = engine_test.connect()
    transaction = connection.begin()
    session = TestingSessionLocal(bind=connection)
    yield session
    session.close()
    transaction.rollback()
    connection.close()

@pytest.fixture(scope="function")
def test_client_with_db(db_session_test):
    def override_get_db():
        try:
            yield db_session_test
        finally:
            db_session_test.close()

    app.dependency_overrides[get_db] = override_get_db
    client = TestClient(app)
    yield client
    del app.dependency_overrides[get_db] # æ¸…ç†è¦†ç›–
```

**åœ¨æµ‹è¯•ä¸­ä½¿ç”¨ fixture:**
```python
# tests/integration/api/v1/test_items_api.py

def test_create_item_db(test_client_with_db):
    response = test_client_with_db.post("/api/v1/items/", json={"name": "DB Item", "price": 20.0})
    assert response.status_code == 201
    # å¯ä»¥è¿›ä¸€æ­¥æ£€æŸ¥æ•°æ®åº“ä¸­çš„æ•°æ®
```

### 4. æ¨¡æ‹Ÿ (Mocking)

ä½¿ç”¨ `unittest.mock.patch` (æˆ– `pytest-mock` æ’ä»¶) æ¥æ¨¡æ‹Ÿå¤–éƒ¨æœåŠ¡æˆ–å¤æ‚çš„ä¾èµ–é¡¹ï¼Œä»¥éš”ç¦»è¢«æµ‹è¯•çš„å•å…ƒã€‚

```python
from unittest.mock import patch

@patch("app.services.item_service.some_external_call")
def test_item_creation_with_mocked_service(mock_external_call, test_client_with_db):
    mock_external_call.return_value = {"status": "success"}
    response = test_client_with_db.post("/api/v1/items/", json={"name": "Mocked Item", "price": 30.0})
    assert response.status_code == 201
    mock_external_call.assert_called_once()
```

## è¿è¡Œæµ‹è¯•å’Œè¦†ç›–ç‡

- **è¿è¡Œæ‰€æœ‰æµ‹è¯•**: `pytest`
- **è¿è¡Œç‰¹å®šæ–‡ä»¶æˆ–æµ‹è¯•**: `pytest tests/integration/api/v1/test_items_api.py::test_create_item_success`
- **ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š**: `pytest --cov=app --cov-report=html` (éœ€è¦å®‰è£… `pytest-cov`)
    - `app` æ˜¯ä½ çš„ä¸»åº”ç”¨ä»£ç ç›®å½•ã€‚
    - HTML æŠ¥å‘Šä¼šç”Ÿæˆåœ¨ `htmlcov/` ç›®å½•ä¸‹ã€‚

## Agentå·¥ä½œæµæµ‹è¯•è§„èŒƒ (PocketFlow)

### ğŸ¤– **Agentæµ‹è¯•æ¶æ„**

åŸºäºPocketFlowçš„Agentéœ€è¦ä¸“é—¨çš„æµ‹è¯•æ–¹æ³•ï¼š

```python
# Agentå·¥ä½œæµæµ‹è¯•åŸºç¡€ç±»
import pytest
from pocketflow import AsyncFlow, AsyncNode
from app.agents.agents.example_agent.flows import create_example_agent_flow
from app.agents.agents.example_agent.nodes import ExampleAnalysisNode

class TestAgentWorkflow:
    """Agentå·¥ä½œæµæµ‹è¯•ç±»"""
    
    @pytest.mark.asyncio
    async def test_agent_flow_execution(self):
        """æµ‹è¯•Agentå·¥ä½œæµå®Œæ•´æ‰§è¡Œ"""
        # 1. å‡†å¤‡æµ‹è¯•æ•°æ®
        shared = {
            "user_message": "æµ‹è¯•ç”¨æˆ·æ¶ˆæ¯",
            "conversation_id": 1,
            "agent_id": "example_agent",
            "memory_strategy": "basic"
        }
        
        # 2. åˆ›å»ºAgent Flow
        agent_flow = create_example_agent_flow()
        
        # 3. æ‰§è¡ŒFlow
        result = await agent_flow.run(shared)
        
        # 4. éªŒè¯ç»“æœ
        assert result["status"] == "success"
        assert "response" in result
        assert result["conversation_id"] == 1
    
    @pytest.mark.asyncio
    async def test_agent_node_execution(self):
        """æµ‹è¯•å•ä¸ªAgentèŠ‚ç‚¹"""
        # 1. åˆ›å»ºèŠ‚ç‚¹å®ä¾‹ï¼ˆéœ€è¦mockä¾èµ–ï¼‰
        mock_repo = MockAgentRepository()
        mock_handler = MockMessageHandler()
        node = ExampleAnalysisNode(mock_repo, mock_handler)
        
        # 2. å‡†å¤‡è¾“å…¥æ•°æ®
        shared = {"user_message": "æµ‹è¯•æ¶ˆæ¯", "conversation_id": 1}
        
        # 3. æ‰§è¡ŒèŠ‚ç‚¹çš„å„ä¸ªé˜¶æ®µ
        prep_result = await node.async_prep(shared)
        exec_result = await node.async_exec(prep_result)
        post_result = await node.async_post(shared, prep_result, exec_result)
        
        # 4. éªŒè¯æ¯ä¸ªé˜¶æ®µçš„ç»“æœ
        assert prep_result is not None
        assert exec_result["status"] == "success"
        assert post_result == "next_node"
```

### ğŸ”§ **Agentæµ‹è¯•Fixtures**

```python
# tests/conftest.py - Agentä¸“ç”¨æµ‹è¯•fixtures
@pytest.fixture
def mock_agent_repository():
    """Mock Agent Repository"""
    class MockAgentRepository:
        async def get_by_id(self, agent_id: str):
            return {
                "agent_id": agent_id,
                "agent_name": "æµ‹è¯•Agent",
                "agent_type": "expert",
                "capabilities": ["analysis"]
            }
        
        async def get_child_agents(self, parent_agent_id: str):
            return [
                {"agent_id": "child_agent_1", "description": "å­Agent1"},
                {"agent_id": "child_agent_2", "description": "å­Agent2"}
            ]
    
    return MockAgentRepository()

@pytest.fixture
def mock_memory_manager():
    """Mock Memory Manager"""
    class MockMemoryManager:
        async def get_context(self, conversation_id: int):
            return {
                "strategy": "basic",
                "history": ["å†å²æ¶ˆæ¯1", "å†å²æ¶ˆæ¯2"],
                "context": "æµ‹è¯•ä¸Šä¸‹æ–‡"
            }
        
        async def update_memory(self, conversation_id: int, agent_response: dict, strategy: str):
            return True
    
    return MockMemoryManager()

@pytest.fixture
def agent_test_shared():
    """Agentæµ‹è¯•çš„æ ‡å‡†sharedæ•°æ®"""
    return {
        "user_message": "æµ‹è¯•ç”¨æˆ·æ¶ˆæ¯",
        "conversation_id": 1,
        "agent_id": "test_agent",
        "memory_strategy": "basic",
        "user_id": "test_user"
    }
```

### ğŸ“Š **æ‰§è¡Œç­–ç•¥æµ‹è¯•**

```python
# æµ‹è¯•TOOLS_STRATEGYæ‰§è¡Œç­–ç•¥
@pytest.mark.asyncio
async def test_tools_strategy_execution(mock_agent_repository, mock_memory_manager):
    """æµ‹è¯•Function Callingç­–ç•¥"""
    from app.agents.nodes import ToolsGenerationNode, LLMDecisionNode
    
    # 1. æµ‹è¯•å·¥å…·ç”ŸæˆèŠ‚ç‚¹
    tools_node = ToolsGenerationNode(mock_agent_repository)
    shared = {"current_agent_id": "parent_agent"}
    
    tools_result = await tools_node.async_exec(shared)
    
    assert "available_tools" in tools_result
    assert len(tools_result["available_tools"]) > 0
    assert tools_result["available_tools"][0]["type"] == "function"

# æµ‹è¯•TASK_STRATEGYæ‰§è¡Œç­–ç•¥
@pytest.mark.asyncio
async def test_task_strategy_execution(mock_agent_repository):
    """æµ‹è¯•ä»»åŠ¡åˆ†è§£ç­–ç•¥"""
    from app.agents.nodes import TaskDecomposeNode, TaskExecutionLoopNode
    
    # 1. æµ‹è¯•ä»»åŠ¡åˆ†è§£èŠ‚ç‚¹
    decompose_node = TaskDecomposeNode(mock_agent_repository)
    shared = {"current_agent_id": "parent_agent", "user_message": "å¤æ‚ä»»åŠ¡"}
    
    decompose_result = await decompose_node.async_exec(shared)
    
    assert "execution_steps" in decompose_result
    assert "current_step" in decompose_result
    assert decompose_result["current_step"] == 0
```

### ğŸ¯ **è®°å¿†ç³»ç»Ÿæµ‹è¯•**

```python
# è®°å¿†ç³»ç»Ÿé›†æˆæµ‹è¯•
@pytest.mark.asyncio
async def test_memory_integration(mock_memory_manager):
    """æµ‹è¯•Agentä¸è®°å¿†ç³»ç»Ÿçš„é›†æˆ"""
    from app.agents.nodes import MemoryAwareAgentNode
    
    # 1. åˆ›å»ºè®°å¿†æ„ŸçŸ¥èŠ‚ç‚¹
    memory_node = MemoryAwareAgentNode(mock_memory_manager)
    
    # 2. æµ‹è¯•è®°å¿†ä¸Šä¸‹æ–‡è·å–
    shared = {"conversation_id": 1}
    prep_result = await memory_node.async_prep(shared)
    
    assert "memory_context" in prep_result
    assert "strategy" in prep_result
    assert prep_result["strategy"] == "basic"
    
    # 3. æµ‹è¯•è®°å¿†æ›´æ–°
    exec_result = {"response": "Agentå“åº”", "status": "success"}
    post_result = await memory_node.async_post(shared, prep_result, exec_result)
    
    assert post_result == "success"
```

## æœ€ä½³å®è·µ

### ğŸ”¬ **é€šç”¨æµ‹è¯•æœ€ä½³å®è·µ**
- **ç‹¬ç«‹æ€§**: æµ‹è¯•åº”ç›¸äº’ç‹¬ç«‹ï¼Œä¸€ä¸ªæµ‹è¯•çš„å¤±è´¥ä¸åº”å½±å“å…¶ä»–æµ‹è¯•ã€‚
- **å¯é‡å¤æ€§**: æµ‹è¯•åº”åœ¨ä»»ä½•ç¯å¢ƒä¸­éƒ½èƒ½äº§ç”Ÿç›¸åŒçš„ç»“æœã€‚
- **æ¸…æ™°æ€§**: æµ‹è¯•ä»£ç åº”æ˜“äºé˜…è¯»å’Œç†è§£ã€‚æµ‹è¯•çš„ç›®çš„åº”æ˜ç¡®ã€‚
- **é€Ÿåº¦**: æµ‹è¯•åº”å°½å¯èƒ½å¿«åœ°è¿è¡Œï¼Œç‰¹åˆ«æ˜¯å•å…ƒæµ‹è¯•ã€‚
- **è¦†ç›–å…³é”®è·¯å¾„**: ä¼˜å…ˆæµ‹è¯•æ ¸å¿ƒåŠŸèƒ½ã€è¾¹ç¼˜æƒ…å†µå’Œå¸¸è§çš„é”™è¯¯åœºæ™¯ã€‚

### ğŸ¤– **Agentæµ‹è¯•æœ€ä½³å®è·µ**
- **Mockä¾èµ–**: ä½¿ç”¨Mockå¯¹è±¡éš”ç¦»AgentèŠ‚ç‚¹çš„å¤–éƒ¨ä¾èµ–ï¼ˆRepositoryã€Handlerç­‰ï¼‰
- **åˆ†å±‚æµ‹è¯•**: åˆ†åˆ«æµ‹è¯•å•ä¸ªèŠ‚ç‚¹å’Œå®Œæ•´å·¥ä½œæµ
- **å¼‚æ­¥å¤„ç†**: ä½¿ç”¨`pytest-asyncio`å¤„ç†å¼‚æ­¥AgentèŠ‚ç‚¹
- **æ•°æ®é©±åŠ¨**: ä½¿ç”¨fixturesæä¾›æ ‡å‡†æµ‹è¯•æ•°æ®
- **ç­–ç•¥è¦†ç›–**: ç¡®ä¿TOOLS_STRATEGYå’ŒTASK_STRATEGYéƒ½æœ‰å¯¹åº”æµ‹è¯•
- **è®°å¿†é›†æˆ**: æµ‹è¯•Agentä¸ä¸åŒè®°å¿†ç­–ç•¥çš„é›†æˆæ•ˆæœ
- **AAA æ¨¡å¼ (Arrange, Act, Assert)**:
    - **Arrange**: è®¾ç½®æµ‹è¯•æ‰€éœ€çš„å‰ææ¡ä»¶å’Œè¾“å…¥æ•°æ®ã€‚
    - **Act**: æ‰§è¡Œè¢«æµ‹è¯•çš„ä»£ç æˆ–æ“ä½œã€‚
    - **Assert**: éªŒè¯ç»“æœæ˜¯å¦ç¬¦åˆé¢„æœŸã€‚
- **ä¸è¦æµ‹è¯• FastAPI å†…éƒ¨**: ä¸“æ³¨äºæµ‹è¯•ä½ çš„åº”ç”¨é€»è¾‘ï¼Œè€Œä¸æ˜¯ FastAPI æ¡†æ¶æœ¬èº«çš„åŠŸèƒ½ï¼ˆä¾‹å¦‚ï¼Œè·¯ç”±åŒ¹é…ã€JSON è§£æç­‰ï¼Œè¿™äº›å·²ç»ç”± FastAPI æµ‹è¯•è¿‡äº†ï¼‰ã€‚
- **æµ‹è¯•æ•°æ®åº“äº¤äº’**: ä¸ºæ•°æ®åº“äº¤äº’ç¼–å†™é›†æˆæµ‹è¯•ã€‚è€ƒè™‘ä½¿ç”¨å†…å­˜æ•°æ®åº“ (å¦‚ SQLite in-memory) è¿›è¡Œå¿«é€Ÿæµ‹è¯•ï¼Œæˆ–ä½¿ç”¨ä¸ç”Ÿäº§ç¯å¢ƒç›¸åŒçš„æ•°æ®åº“å¼•æ“çš„æµ‹è¯•å®ä¾‹ä»¥è·å¾—æ›´å‡†ç¡®çš„ç»“æœã€‚
- **æŒç»­é›†æˆ (CI)**: å°†æµ‹è¯•é›†æˆåˆ° CI/CD æµç¨‹ä¸­ï¼Œç¡®ä¿æ¯æ¬¡ä»£ç å˜æ›´éƒ½ç»è¿‡æµ‹è¯•ã€‚
```