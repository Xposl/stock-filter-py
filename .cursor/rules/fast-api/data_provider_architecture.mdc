---
description: 
globs: 
alwaysApply: false
---
# InvestNote-py 数据提供者架构设计

## 概述

本文档描述了 InvestNote-py 项目的数据提供者层（Data Provider Layer）和雪球抽象层（Xueqiu Abstraction Layer）的架构设计，这两个层次的引入解决了代码重复、数据源管理复杂性和系统可扩展性等关键问题。

**设计目标**:
- 消除雪球相关模块的代码重复
- 实现AKShare数据源优先，雪球数据源补充的策略
- 提供统一的股票数据访问接口
- 支持智能数据源降级和错误处理

## 🏗️ 整体架构设计

### 架构层次图

```
┌─────────────────────────────────────────────────────────────┐
│                    Handler Layer                            │
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │ TickerHandler   │  │AnalysisHandler  │  │ NewsHandler  │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────┐
│                Data Provider Layer                          │
│  ┌────────────────────────────────────────────────────────┐ │
│  │              StockDataFactory                          │ │
│  │  ┌──────────────────┐  ┌────────────────────────────┐  │ │
│  │  │ AKShareProvider  │  │     XueqiuProvider         │  │ │
│  │  │   (Priority:100) │  │     (Priority:50)          │  │ │
│  │  └──────────────────┘  └────────────────────────────┘  │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────┐
│               Xueqiu Abstraction Layer                      │
│  ┌────────────────────────────────────────────────────────┐ │
│  │            XueqiuClientFactory                         │ │
│  │  ┌──────────────────┐  ┌────────────────────────────┐  │ │
│  │  │ XueqiuNewsClient │  │   XueqiuStockClient        │  │ │
│  │  │                  │  │                            │  │ │
│  │  └──────────────────┘  └────────────────────────────┘  │ │
│  │  ┌─────────────────────────────────────────────────────┐ │
│  │  │            XueqiuBaseClient                         │ │
│  │  │    (Session, Token, HTTP Management)                │ │
│  │  └─────────────────────────────────────────────────────┘ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────┐
│                 External APIs                               │
│  ┌──────────────┐  ┌──────────────┐  ┌────────────────────┐ │
│  │   AKShare    │  │   Xueqiu     │  │   Other Sources    │ │
│  │     API      │  │     API      │  │    (Future)        │ │
│  └──────────────┘  └──────────────┘  └────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

## 📊 数据提供者层 (Data Provider Layer)

### 核心组件

#### 1. StockDataProvider 抽象接口
- **文件**: [core/data_providers/stock_data_provider.py](mdc:core/data_providers/stock_data_provider.py)
- **作用**: 定义统一的股票数据访问接口
- **特性**:
  - 支持多市场（A股、港股、美股、英股）
  - 统一的数据周期枚举
  - 错误处理和优先级管理
  - 自动降级机制

```python
class StockDataProvider(ABC):
    """股票数据提供者抽象基类"""
    
    @abstractmethod
    def get_stock_info(self, symbol: str, market: StockMarket = None) -> Optional[Dict[str, Any]]:
        """获取股票基本信息"""
        pass
    
    @abstractmethod
    def get_stock_quote(self, symbol: str, market: StockMarket = None) -> Optional[Dict[str, Any]]:
        """获取股票实时行情"""
        pass
    
    @abstractmethod
    def get_stock_history(self, symbol: str, start_date, end_date=None) -> Optional[pd.DataFrame]:
        """获取股票历史数据"""
        pass
```

#### 2. AKShareProvider 主要数据源
- **文件**: [core/data_providers/akshare_provider.py](mdc:core/data_providers/akshare_provider.py)
- **优先级**: 100 (最高)
- **覆盖范围**: A股、港股、美股全面支持
- **特色功能**:
  - 自动市场检测
  - 股票代码标准化
  - 完整的CRUD操作支持
  - 丰富的搜索功能

```python
class AKShareProvider(StockDataProvider):
    def __init__(self):
        super().__init__(name="AKShare", priority=100)
        self._supported_markets = [StockMarket.A_SHARE, StockMarket.HONG_KONG, StockMarket.US]
    
    def get_stock_info(self, symbol: str, market: StockMarket = None):
        # 使用akshare获取数据
        df = ak.stock_zh_a_spot_em()
        # 数据处理和格式化
        return standardized_data
```

#### 3. XueqiuProvider 补充数据源
- **文件**: [core/data_providers/xueqiu_provider.py](mdc:core/data_providers/xueqiu_provider.py)
- **优先级**: 50 (中等)
- **作用**: AKShare的补充和备用
- **特性**:
  - 使用重构后的雪球抽象层
  - 专注于实时行情和公司信息
  - 提供异步操作支持

```python
class XueqiuProvider(StockDataProvider):
    def __init__(self):
        super().__init__(name="雪球", priority=50)
        self._client = create_stock_client()
    
    def get_stock_quote(self, symbol: str, market: StockMarket = None):
        # 使用雪球抽象层
        quote = self._client.get_stock_quote(symbol)
        return standardized_quote_data
```

#### 4. StockDataFactory 策略管理器
- **文件**: [core/data_providers/stock_data_factory.py](mdc:core/data_providers/stock_data_factory.py)
- **设计模式**: 策略模式 + 工厂模式
- **核心功能**:
  - 智能数据源选择
  - 自动降级策略
  - 错误计数和监控
  - 全局工厂实例管理

```python
class StockDataFactory:
    def get_stock_info(self, symbol: str) -> StockDataResponse:
        for provider in self.get_available_providers():
            try:
                data = provider.get_stock_info(symbol)
                if data:
                    return StockDataResponse(data, provider.name, True)
            except Exception as e:
                provider._handle_error(e, "获取股票信息")
        
        return StockDataResponse(None, "None", False, "所有提供者均失败")
```

### 智能降级策略

```mermaid
graph TD
    A[业务请求] --> B{检查AKShare可用性}
    B -->|可用| C[调用AKShare获取数据]
    B -->|不可用| D{检查雪球可用性}
    
    C --> E{数据获取成功?}
    E -->|成功| F[返回AKShare数据]
    E -->|失败| G[AKShare错误计数+1]
    
    D -->|可用| H[调用雪球获取数据]
    D -->|不可用| L[返回失败响应]
    
    G --> I{错误次数 < 5?}
    I -->|是| D
    I -->|否| J[标记AKShare不可用]
    
    H --> K{数据获取成功?}
    K -->|成功| M[返回雪球数据]
    K -->|失败| N[雪球错误计数+1]
    
    J --> D
    N --> L
    
    style F fill:#90EE90
    style M fill:#87CEEB
    style L fill:#FFB6C1
```

## 🌐 雪球抽象层 (Xueqiu Abstraction Layer)

### 设计原则

#### 1. 分层抽象原则
- **基础层**: XueqiuBaseClient 统一会话、令牌和HTTP管理
- **专业层**: XueqiuNewsClient / XueqiuStockClient 各司其职
- **工厂层**: XueqiuClientFactory 统一创建和管理

#### 2. 职责分离原则
- **会话管理**: 统一在基础客户端处理
- **业务逻辑**: 分别在专业客户端实现
- **错误处理**: 各层级独立处理，统一策略

#### 3. 向后兼容原则
- 保留原有方法签名
- 提供兼容性函数
- 渐进式迁移支持

### 核心组件

#### 1. XueqiuBaseClient 基础抽象客户端
- **文件**: [core/utils/xueqiu/xueqiu_base_client.py](mdc:core/utils/xueqiu/xueqiu_base_client.py)
- **责任**:
  - 统一的会话管理（aiohttp.ClientSession）
  - 令牌获取策略（pyppeteer + urllib备用）
  - HTTP请求封装（同步/异步）
  - 错误处理和重试机制

```python
class XueqiuBaseClient(ABC):
    """雪球数据访问基础客户端"""
    
    async def _ensure_token(self) -> bool:
        """确保有可用的token"""
        # 首先尝试pyppeteer
        self.xqat = await self._get_token_with_puppeteer()
        
        # 失败则使用urllib备用
        if not self.xqat:
            self.xqat = await asyncio.get_event_loop().run_in_executor(
                None, self._get_token_with_urllib
            )
        
        return self.xqat is not None
    
    async def _async_request(self, url: str, retry: bool = True):
        """统一的异步HTTP请求"""
        if not await self._ensure_token():
            return None
            
        # 请求处理逻辑
        # 自动重试机制
```

#### 2. XueqiuNewsClient 新闻专用客户端
- **文件**: [core/utils/xueqiu/xueqiu_news_client.py](mdc:core/utils/xueqiu/xueqiu_news_client.py)
- **继承**: XueqiuBaseClient
- **专业功能**:
  - 时间线数据抓取和解析
  - 股票符号提取和识别
  - 重要性评分计算
  - 内容过滤和质量控制

```python
class XueqiuNewsClient(XueqiuBaseClient):
    """雪球新闻聚合客户端"""
    
    def get_client_type(self) -> str:
        return "news"
    
    async def fetch_timeline_data(self, news_source) -> List[Dict[str, Any]]:
        """抓取雪球时间线数据"""
        timeline_data = await self._fetch_timeline_api(news_source.url)
        
        articles = []
        for item in timeline_data.get('list', []):
            article_data = await self._parse_timeline_item(item, news_source)
            if self._should_include_article(article_data, news_source):
                articles.append(article_data)
        
        return articles
```

#### 3. XueqiuStockClient 股票专用客户端
- **文件**: [core/utils/xueqiu/xueqiu_stock_client.py](mdc:core/utils/xueqiu/xueqiu_stock_client.py)
- **继承**: XueqiuBaseClient
- **专业功能**:
  - 股票报价获取
  - 公司信息查询（A股/港股/美股）
  - 历史数据获取
  - 同步/异步接口支持

```python
class XueqiuStockClient(XueqiuBaseClient):
    """雪球股票数据客户端"""
    
    def get_client_type(self) -> str:
        return "stock"
    
    def get_stock_quote(self, code: str) -> Optional[XueqiuStockQuote]:
        """获取股票报价"""
        symbol = self._get_symbol(code)
        url = f'https://stock.xueqiu.com/v5/stock/quote.json?symbol={symbol}'
        
        content = self._sync_request(url)
        # 数据解析和返回
        
    async def get_stock_quote_async(self, code: str) -> Optional[XueqiuStockQuote]:
        """异步获取股票报价"""
        # 异步版本实现
```

#### 4. XueqiuClientFactory 客户端工厂
- **文件**: [core/utils/xueqiu/xueqiu_client_factory.py](mdc:core/utils/xueqiu/xueqiu_client_factory.py)
- **设计模式**: 工厂模式
- **功能**:
  - 类型安全的客户端创建
  - 客户端实例缓存
  - 会话共享管理
  - 便捷函数提供

```python
class XueqiuClientFactory:
    """雪球客户端工厂"""
    
    def create_client(self, client_type: Union[XueqiuClientType, str]):
        """创建雪球客户端"""
        if client_type == XueqiuClientType.NEWS:
            client = XueqiuNewsClient(session=self.session)
        elif client_type == XueqiuClientType.STOCK:
            client = XueqiuStockClient(session=self.session)
        
        self._clients[client_type.value] = client
        return client

# 全局便捷函数
def create_news_client(session=None) -> XueqiuNewsClient:
    """快速创建新闻客户端"""
    
def create_stock_client(session=None) -> XueqiuStockClient:
    """快速创建股票客户端"""
```

## 🔄 代码重构和迁移

### 重构前后对比

#### 原有问题
```python
# 问题1: 代码重复
# xueqiu_aggregator.py 和 xueqiu_api.py 都有令牌获取逻辑

# 问题2: 会话管理混乱  
# 每个模块都创建自己的HTTP会话

# 问题3: 错误处理不统一
# 不同模块有不同的错误处理策略
```

#### 重构后改进
```python
# 解决方案1: 统一抽象层
# 所有雪球相关模块使用 XueqiuBaseClient

# 解决方案2: 工厂管理
# 通过 XueqiuClientFactory 统一创建和管理

# 解决方案3: 策略模式
# 通过 StockDataFactory 管理多数据源
```

### 迁移指南

#### 1. 现有代码适配
```python
# 旧代码
from core.utils.xueqiu.xueqiu_api import XueqiuApi

api = XueqiuApi()
quote = api.get_stock_quote("SH600000")

# 新代码 - 直接使用数据工厂
from core.data_providers.stock_data_factory import get_stock_quote

response = get_stock_quote("600000", market=StockMarket.A_SHARE)
if response.success:
    quote_data = response.data

# 或者指定使用雪球数据源
response = get_stock_quote("600000", provider_name="雪球")
```

#### 2. 新闻聚合器适配
```python
# 旧代码
from core.news_aggregator.xueqiu_aggregator import fetch_xueqiu_data

articles = await fetch_xueqiu_data(news_source)

# 新代码 - 使用重构后的聚合器
from core.news_aggregator.xueqiu_aggregator import XueqiuAggregator

async with XueqiuAggregator() as aggregator:
    articles = await aggregator.fetch_xueqiu_timeline(news_source)

# 向后兼容函数仍然可用
articles = await fetch_xueqiu_data(news_source)  # 内部使用新抽象层
```

## 📈 性能优化

### 连接复用
- **会话共享**: 多个客户端共享aiohttp.ClientSession
- **连接池**: 优化的TCP连接器配置
- **超时管理**: 合理的连接和读取超时设置

### 错误处理优化
- **智能重试**: 区分临时错误和永久错误
- **熔断机制**: 连续失败后暂时停用数据源
- **错误缓存**: 避免重复请求已知失败的资源

### 令牌管理优化
- **令牌缓存**: 避免频繁获取令牌
- **多策略获取**: pyppeteer失败时自动切换urllib
- **令牌有效性检查**: 自动检测和刷新过期令牌

## 🚀 扩展性设计

### 新数据源接入
```python
# 添加新的数据源只需实现StockDataProvider接口
class TushareProvider(StockDataProvider):
    def __init__(self):
        super().__init__(name="Tushare", priority=80)
    
    def get_stock_info(self, symbol: str, market: StockMarket = None):
        # Tushare API调用实现
        pass

# 在工厂中注册
factory.add_provider(TushareProvider())
```

### 新雪球客户端类型
```python
# 添加新的雪球客户端类型
class XueqiuResearchClient(XueqiuBaseClient):
    def get_client_type(self) -> str:
        return "research"
    
    def get_research_reports(self, symbol: str):
        # 研究报告获取实现
        pass

# 在工厂中支持
class XueqiuClientType(Enum):
    NEWS = "news"
    STOCK = "stock"
    RESEARCH = "research"  # 新增类型
```

## 🛡️ 错误处理策略

### 分层错误处理
```mermaid
graph TD
    A[业务请求] --> B[StockDataFactory]
    B --> C[AKShareProvider]
    B --> D[XueqiuProvider]
    
    C --> E{AKShare调用成功?}
    E -->|失败| F[记录错误]
    F --> G{错误次数 < 阈值?}
    G -->|否| H[标记不可用]
    G -->|是| I[继续使用]
    
    D --> J[XueqiuBaseClient]
    J --> K{令牌获取成功?}
    K -->|失败| L[尝试备用方法]
    L --> M{备用方法成功?}
    M -->|失败| N[标记雪球不可用]
    
    E -->|成功| O[返回数据]
    K -->|成功| P[执行API调用]
    P --> Q{API调用成功?}
    Q -->|成功| O
    Q -->|失败| R[重试机制]
    
    style O fill:#90EE90
    style H fill:#FFB6C1
    style N fill:#FFB6C1
```

### 错误恢复机制
- **自动重试**: 临时网络错误自动重试
- **降级策略**: 主要数据源失败时自动切换备用源
- **错误重置**: 定期重置错误计数，允许恢复
- **监控告警**: 关键错误及时通知运维人员

## 📊 监控和指标

### 关键指标
- **数据源可用性**: 各数据源的实时可用状态
- **响应时间**: API调用的平均响应时间
- **成功率**: 各数据源的请求成功率
- **错误分布**: 不同类型错误的分布情况

### 监控实现
```python
# 数据源状态监控
def get_provider_status() -> Dict[str, Dict[str, Any]]:
    """获取所有提供者的状态"""
    status = {}
    for provider in factory._providers:
        status[provider.name] = {
            'priority': provider.priority,
            'is_available': provider.is_available,
            'error_count': provider._error_count,
            'supported_markets': [m.value for m in provider.get_supported_markets()]
        }
    return status
```

## 📚 最佳实践

### 使用建议
1. **优先使用工厂**: 通过StockDataFactory访问股票数据，而非直接调用具体提供者
2. **指定市场类型**: 明确指定股票市场类型，提高数据获取准确性
3. **处理失败情况**: 始终检查返回的StockDataResponse.success状态
4. **合理使用异步**: I/O密集操作优先使用异步接口
5. **监控数据源状态**: 定期检查数据源可用性，及时发现问题

### 性能优化建议
1. **批量操作**: 尽可能使用批量API减少请求次数
2. **缓存策略**: 对于不经常变化的数据（如公司信息）实现缓存
3. **连接复用**: 使用长连接和连接池减少连接开销
4. **并发控制**: 合理控制并发请求数量，避免触发API限制

### 错误处理建议
1. **区分错误类型**: 区分临时错误（网络超时）和永久错误（API密钥无效）
2. **实现熔断机制**: 连续失败后暂时停用数据源，避免无谓重试
3. **记录详细日志**: 记录足够的错误信息用于问题诊断
4. **用户友好提示**: 向用户提供有意义的错误信息，而非技术细节

